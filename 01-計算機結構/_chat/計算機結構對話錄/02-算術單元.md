# 算術單元

* [AI對話](https://aistudio.google.com/app/prompts?state=%7B%22ids%22:%5B%221B6lBGVJkpC39Ev4WCzpeFu0IQoYET3Vd%22%5D,%22action%22:%22open%22,%22userId%22:%22111605452542833299008%22,%22resourceKeys%22:%7B%7D%7D&usp=sharing)

## Q: 加法器是什麼？

好的，同學請坐！

歡迎來到數位邏輯與計算機結構的世界！這兩門課是所有資工學生的內功心法，會帶你從最底層的 0 和 1，一路蓋出我們現在每天在用的電腦。

今天，我們就從最基本也最重要的東西開始：**加法器 (Adder)**。

---

### 什麼是加法器？為什麼它這麼重要？

想像一下，電腦最核心的功能是什麼？沒錯，就是**計算**！而所有複雜的計算，無論是乘法、除法，甚至是更複雜的數學運算，最終都可以拆解成最基本的**加法**。

> **加法器**，顧名思義，就是一個用來執行「加法」運算的電子電路。它是電腦中央處理器 (CPU) 裡面，算術邏輯單元 (Arithmetic Logic Unit, ALU) 的核心組件。

你可以把它想像成電腦心臟中的一個小齒輪，雖然小，但沒有它，整個心臟就無法跳動。你玩的遊戲、看的影片、寫的程式，所有運算的背後，都有加法器在默默地、以極高的速度進行數十億次的加法運算。

### 從最簡單的開始：一次只加一個位元

我們先別想太複雜的數字，回到電腦最單純的世界：二進位。在二進位裡，只有 0 和 1。

我們來試著做個一位數的加法：

*   $0 + 0 = 0$
*   $0 + 1 = 1$
*   $1 + 0 = 1$
*   $1 + 1 = 10$ (這裡的 10 是二進位，意思是「2」。我們得到一個結果 `0`，和一個**進位 (Carry)** `1`)

這個簡單的運算，我們就可以用數位邏輯電路來實現。

#### 1. 半加器 (Half Adder)

「半加器」是我們能做出來最簡單的加法器。它只處理兩件事：

1.  接收**兩個**一位元的輸入 (我們叫它 A 和 B)。
2.  產生**兩個**輸出：
    *   **和 (Sum)**：A 跟 B 相加的結果。
    *   **進位 (Carry-out)**：A 跟 B 相加後，是否需要進位。

| A (輸入) | B (輸入) | Sum (和) | Carry-out (進位) |
| :------: | :------: | :------: | :--------------: |
|    0     |    0     |    0     |        0         |
|    0     |    1     |    1     |        0         |
|    1     |    0     |    1     |        0         |
|    1     |    1     |    0     |        1         |

仔細觀察上面的真值表 (Truth Table)：

*   `Sum` 的行為是不是很像 **XOR (互斥或)** 閘？ (只有當 A、B 輸入不同時，輸出才為 1)
*   `Carry-out` 的行為是不是很像 **AND (及)** 閘？ (只有當 A、B 輸入皆為 1 時，輸出才為 1)

所以，我們可以用一個 XOR 閘和一個 AND 閘來兜出一個半加器！



#### 2. 全加器 (Full Adder)

半加器很棒，但它有個問題：它沒辦法處理「從前一位來的進位」。

想像我們在做多位數的加法，例如 $01 + 01$。在計算個位數 $1+1$ 時，我們會得到結果 `0` 和一個進位 `1`。在計算十位數時，我們需要把 `0 + 0` 再加上**前一位來的進位 `1`**。

半加器只有兩個輸入，沒辦法處理這個「前一位來的進位」。這時候，**全加器 (Full Adder)** 就登場了！

全加器有**三個**輸入：

1.  輸入 A
2.  輸入 B
3.  **前一位的進位 (Carry-in)**

同樣地，它會產生**兩個**輸出：

1.  **和 (Sum)**
2.  **這一位的進位 (Carry-out)**

| A | B | Carry-in | Sum | Carry-out |
| :-: | :-: | :------: | :-: | :-------: |
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 0 |
| 0 | 1 | 0 | 1 | 0 |
| 0 | 1 | 1 | 0 | 1 |
| 1 | 0 | 0 | 1 | 0 |
| 1 | 0 | 1 | 0 | 1 |
| 1 | 1 | 0 | 0 | 1 |
| 1 | 1 | 1 | 1 | 1 |

一個很酷的事實是：我們可以用**兩個半加器**和一個 **OR (或)** 閘來兜出一個全加器！



### 用程式碼描述硬體：Verilog 初體驗

在數位邏輯的世界裡，我們不只畫電路圖，我們還會用**硬體描述語言 (Hardware Description Language, HDL)** 來「寫」出我們的電路。Verilog 就是其中最流行的一種。

用 Verilog 來寫一個全加器會長這樣：

```verilog
// 模組名稱是 FullAdder，它有 a, b, cin 這三個輸入
// 以及 sum, cout 這兩個輸出
module FullAdder(
    input a,
    input b,
    input cin,
    output sum,
    output cout
);

    // 我們可以用一行程式碼來描述 sum 和 cout 的邏輯
    // assign {cout, sum} = a + b + cin; 
    // 上面這行是比較抽象的寫法，我們也可以用更底層的邏輯閘來寫：

    wire s1, c1, c2; // 定義中間訊號線

    // 第一個半加器
    assign s1 = a ^ b;      // Sum of a and b (XOR)
    assign c1 = a & b;      // Carry of a and b (AND)

    // 第二個半加器
    assign sum = s1 ^ cin;  // Final sum
    assign c2 = s1 & cin;   // Carry of the second stage

    // 組合兩個進位
    assign cout = c1 | c2;  // Final carry-out (OR)

endmodule
```

是不是很神奇？我們用類似寫程式的方式，來描述一個實際的電子電路應該如何運作。當這段程式碼被送到專門的工具 (合成器 Synthesizer) 處理後，它就會自動幫我們產生由 AND, OR, XOR 等邏輯閘組成的電路圖！

### 從一位到多位：漣波進位加法器 (Ripple-Carry Adder)

現在我們有了可以處理一位數加法（包含進位）的全加器，要怎麼做多位數的加法，例如一個 4 位元的加法器呢？

很簡單，我們把好幾個全加器「串」起來就好了！

想像一下我們手算 $1011 + 0110$ 的過程：

1.  **個位數**：$1+0=1$，進位是 0。
2.  **第二位**：$1+1+$ **(前位的進位 0)** $=0$，進位是 1。
3.  **第三位**：$0+1+$ **(前位的進位 1)** $=0$，進位是 1。
4.  **第四位**：$1+0+$ **(前位的進位 1)** $=0$，進位是 1。

結果是 $10001$。

我們可以把 4 個全加器像骨牌一樣串接起來：第一個全加器的 `Carry-out` 接到第二個全加器的 `Carry-in`，第二個的 `Carry-out` 接到第三個的 `Carry-in`，以此類推。



這種結構就叫做**漣波進位加法器 (Ripple-Carry Adder)**，因為進位訊號就像水中的漣漪一樣，從最低位元一路「傳遞」到最高位元。

### 總結一下今天的重點

1.  **加法器**是電腦運算的核心，負責執行加法。
2.  **半加器**處理兩個一位元的相加，產生「和」與「進位」。
3.  **全加器**處理三個一位元的相加（包含前一位的進位），是建構實用加法器的基礎。
4.  我們可以把多個**全加器**串接起來，像樂高一樣，組合成更多位元的加法器，例如 **4 位元漣波進位加法器**。
5.  **Verilog** 是一種硬體描述語言，讓 我們可以用程式碼來設計和描述數位電路。

今天我們從最基本的加法運算，一步步用邏輯閘蓋出了能夠處理多位元數字的加法器。這個「把簡單的東西組合起來，創造出更複雜、更強大功能」的概念，是整個計算機科學的精髓。

這只是個開始，接下來我們會探索更快的加法器、減法器、乘法器，最終你會親手揭開 CPU 的神秘面紗。

有沒有什麼問題？不用怕，儘管問！

## Q: 那如何用上述 FullAdder 做出 16 位元加法器呢？

問得非常好！這正是我們要做的下一步，也是數位邏輯設計中一個最核心的概念：**模組化設計 (Modular Design)**。

我們已經設計好一個「積木」(`FullAdder`)，現在我們要做的就是用很多個這種積木來蓋一個更大的城堡 (`Adder_16bit`)。

---

### 設計思路：串接積木

我們的目標是做出一個能計算 `A[15:0] + B[15:0]` 的 16 位元加法器。這裡的 `[15:0]` 表示這是一個 16 位元的訊號，從第 0 位到第 15 位。

就像我們手算加法一樣，從最右邊（最低位，LSB - Least Significant Bit）開始，一路往左算到最左邊（最高位，MSB - Most Significant Bit）。

1.  **第 0 位 (最右邊)**：我們需要計算 `A[0] + B[0]`。這還需要一個初始的「進位輸入 (Carry-in)」，對於一次獨立的加法運算，這個 `Cin` 通常是 0。這個計算會產生 `Sum[0]` 和一個進位 `C1`。
2.  **第 1 位**：我們需要計算 `A[1] + B[1]` 再**加上**從前一位來的進位 `C1`。這個計算會產生 `Sum[1]` 和一個新的進位 `C2`。
3.  **第 2 位**：我們需要計算 `A[2] + B[2]` 再**加上**從前一位來的進位 `C2`。這個計算會產生 `Sum[2]` 和一個新的進位 `C3`。
4.  **... 以此類推 ...**
5.  **第 15 位 (最左邊)**：我們需要計算 `A[15] + B[15]` 再**加上**從第 14 位來的進位 `C15`。這個計算會產生 `Sum[15]` 和一個最終的進位 `C16` (我們通常叫它 `Cout`)。

你看，這個過程就是不斷重複使用全加器！第 `i` 個全加器的 `Carry-out` 會直接連到第 `i+1` 個全加器的 `Carry-in`。

這個結構，就是我們上次提到的**漣波進位加法器 (Ripple-Carry Adder)**。

### 視覺化連接圖



想像我們有 16 個 `FullAdder` 的晶片，我們要把它們像這樣連起來：

```
      Cin (初始進位, 通常=0)
       |
       v
+----------+   A[0], B[0] -> |   FA_0   | -> Sum[0]
|          |------------o-----------> C[1] (第一個進位)
+----------+            |
                          v
+----------+   A[1], B[1] -> |   FA_1   | -> Sum[1]
|          |------------o-----------> C[2]
+----------+            |
                          v
                          .
                          .
                          .
                          v
+----------+  A[15],B[15] -> |  FA_15   | -> Sum[15]
|          |------------o-----------> Cout (最終進位)
+----------+
```

### 用 Verilog 實作 16 位元加法器

現在，我們要把這個「串接」的動作寫成 Verilog 程式碼。

首先，我們要定義這個 16 位元加法器的模組。它會有什麼輸入和輸出？
*   **輸入**:
    *   `A`: 16 位元的數字
    *   `B`: 16 位元的數字
    *   `Cin`: 1 位元的初始進位
*   **輸出**:
    *   `Sum`: 16 位元的和
    *   `Cout`: 1 位元的最終進位

```verilog
// 這是我們新的模組：一個 16 位元的加法器
module Adder_16bit(
    input  [15:0] A,    // 16 位元的輸入 A
    input  [15:0] B,    // 16 位元的輸入 B
    input         Cin,  // 初始進位
    output [15:0] Sum,  // 16 位元的和
    output        Cout  // 最終進位
);

    // 我們需要一些「電線」來連接這些 FullAdder 的進位訊號。
    // 我們需要 16 條線，C[0] 到 C[15]，來傳遞中間的進位。
    // C[0] 用來接收初始的 Cin，C[16] 就是最終的 Cout。
    wire [16:0] C;

    // 將外部的初始進位 Cin 連接到我們內部進位線的第一條
    assign C[0] = Cin;

    // 現在，我們要「例化 (Instantiate)」16 次 FullAdder 模組
    // 我們可以用一個 for 迴圈來自動產生這 16 個 FullAdder
    // 這是 HDL 的強大之處：用軟體迴圈來產生重複的硬體結構！
    genvar i; // 宣告一個給 generate for-loop 用的變數
    generate
        for (i = 0; i < 16; i = i + 1) begin : fa_instance_loop
            // 在迴圈的每一次，都建立一個 FullAdder 實例
            FullAdder fa_unit (
                .a    (A[i]),      // 將 A 的第 i 位連接到 fa 的 a 輸入
                .b    (B[i]),      // 將 B 的第 i 位連接到 fa 的 b 輸入
                .cin  (C[i]),      // 將前一個進位 C[i] 連接到 fa 的 cin 輸入
                .sum  (Sum[i]),    // 將 fa 的 sum 輸出連接到 Sum 的第 i 位
                .cout (C[i+1])     // 將 fa 的 cout 輸出連接到下一個進位 C[i+1]
            );
        end
    endgenerate

    // 將最後一條進位線 C[16] 連接到模組的最終輸出 Cout
    assign Cout = C[16];

endmodule

// 為了完整，我們把上次的 FullAdder 模組也放在這裡
// 在實際的專案中，它會是另一個 .v 檔案
module FullAdder(
    input a,
    input b,
    input cin,
    output sum,
    output cout
);
    assign {cout, sum} = a + b + cin;
endmodule
```

### 程式碼解說

1.  **`input [15:0] A`**: 這定義了一個 16 位元的輸入 `A`。我們稱之為**匯流排 (Bus)** 或**向量 (Vector)**。你可以把它想像成 16 條並排的電線。
2.  **`wire [16:0] C`**: 我們宣告了一組 17 條的內部線路 `C`，專門用來傳遞進位訊號。`C[0]` 用於接收最一開始的 `Cin`，而 `C[1]` 就是第 0 個 `FullAdder` 產生的進位，`C[2]` 是第 1 個 `FullAdder` 產生的進位... 一直到 `C[16]`，它是第 15 個 `FullAdder` 產生的最終進位。
3.  **`generate for` 迴圈**: 這是 Verilog 中一個非常強大的語法。它不是一個在硬體中會「跑」的迴圈，而是在「**編譯時期**」的迴圈。編譯器看到這段程式碼，就會自動幫我們展開，產生 16 個 `FullAdder` 的實例 (instance)，並把線路都接好。這讓我們可以用幾行程式碼就描述非常龐大且規律的電路，而不用手動複製貼上 16 次。
4.  **`.a(A[i]), .b(B[i])`**: 這種 `.名稱(訊號)` 的語法叫做「**依名稱連接 (Connect by Name)**」。它清楚地表示我們把模組外部的訊號 `A[i]` 連接到 `FullAdder` 內部名為 `a` 的輸入埠，可讀性很高，不容易出錯。

### 漣波進位加法器的優點與缺點

*   **優點**:
    *   **結構簡單**：非常直觀，容易理解和設計。
    *   **面積小**：在晶片上佔用的空間相對較小，因為線路很規律。

*   **缺點**:
    *   **速度慢**！這是它最致命的缺點。

為什麼慢？想像一下，為了算出 `Sum[15]`，我們必須要等到 `C[15]` 的結果出來。而 `C[15]` 的計算又依賴 `C[14]`，`C[14]` 依賴 `C[13]`... 這樣一路回推，`Sum[15]` 的最終結果必須要等進位訊號像漣漪一樣，從第 0 位一路「**傳播 (propagate)**」到第 15 位，才能確定。

這個延遲時間和你的加法器位元數 `N` 成正比。對於 16 位元可能還好，但對於現在電腦常見的 64 位元加法器，這個延遲就會變得無法接受。

這也正是計算機結構中有趣的地方：**永遠存在權衡 (Trade-off)**。我們用簡單的設計換來了較慢的速度。這也驅使我們去發明更聰明、更快速的加法器電路，例如「**進位預測加法器 (Carry-Lookahead Adder)**」，這將是我們之後會探討的主題！

現在，你已經知道如何用最基本的邏輯單元，像堆積木一樣，建構出更複雜且實用的算術電路了。這就是硬體設計的魅力所在！

## Q: 二補數是什麼？

太棒了，這個問題正好接續著我們的話題！

我們已經用 `FullAdder` 蓋出了一個強大的 16 位元加法器。但它只會做「加法」。如果我們想做「減法」，例如 $A - B$，該怎麼辦？

最直覺的想法是：「那我們再來設計一個全新的『減法器』電路吧！」

但這在硬體設計上是很浪費的。晶片上的每一寸面積都無比寶貴，如果我們能用現有的加法器「順便」把減法也做了，那該有多好？

這就是**二補數 (Two's Complement)** 登場的時刻了。

> **二補數**是一種在電腦系統中表示**有號整數**（正數、負數和零）的方法。它的最大優點，就是讓電腦可以用**加法器**來直接執行**減法運算**。

換句話說，它是一個絕妙的數學技巧，可以簡化我們的硬體設計！

---

### 核心思想：把減法變成加法

我們在小學都學過，$A - B$ 其實就等於 $A + (-B)$。

這個概念很簡單。如果我們能找到一種方法，用二進位來表示 `-B`，那麼我們就可以把 $A$ 和這個代表 `-B` 的二進位數，一起丟進我們剛做好的加法器裡，得到的結果就會是 $A-B$ 的答案！

二補數，就是那個「用二進位來表示負數」的絕佳方法。

### 如何計算二補數？(如何找出 `-B`？)

假設我們在一個 **8 位元** 的系統中工作。要找出一個數字 `B` 的負數 `-B`，規則如下：

**「先變反相，再加一」** (Invert, then add one)

我們來實際操作一次。假設我們要計算 $7 - 5$，也就是 $7 + (-5)$。

1.  **先寫出 +5 的二進位表示：**
    在 8 位元系統中，5 是 `0000 0101`。

2.  **找出 -5 的二補數表示：**
    *   **第一步：變反相 (Invert)**
        把所有的 0 變成 1，所有的 1 變成 0。
        `0000 0101` -> `1111 1010`
        (這個 `1111 1010` 其實叫做「一補數 (One's Complement)」)

    *   **第二步：加一 (Add one)**
        把上一步的結果加上 1。
        ```
          1111 1010
        + 0000 0001
        -----------
          1111 1011
        ```
    *   **結論：** 在 8 位元二補數系統中，`1111 1011` 這個位元組合，代表的數字就是 **-5**。

3.  **執行「加法」 $7 + (-5)$：**
    *   +7 的二進位是 `0000 0111`。
    *   -5 的二進位是 `1111 1011`。

    現在，把這兩個數丟進我們的 8 位元加法器：
    ```
      0000 0111   (A = 7)
    + 1111 1011   (B = -5)
    -----------
    1 0000 0010   (Sum = 2)
    ```
    看到了嗎？加法器吐出的結果是 `1 0000 0010`。因為我們是在一個 8 位元的系統中，第 9 個位元 (最左邊的那個 `1`) 會被當作**進位 (Carry-out)** 而**捨棄**。剩下的 8 位元是 `0000 0010`，這正是十進位的 **2**！

**神奇的事情發生了：我們的加法器，完全沒做任何修改，就成功地完成了減法運算！**

### 二補數系統的幾個重要特性

1.  **符號位 (Sign Bit)**
    在二補數系統中，最左邊的位元 (MSB - Most Significant Bit) 可以用來判斷正負。
    *   如果 MSB 是 **0**，代表這個數是**正數或零**。
    *   如果 MSB 是 **1**，代表這個數是**負數**。
    *   例如：`0000 0111` (7) 的 MSB 是 0。`1111 1011` (-5) 的 MSB 是 1。

2.  **唯一的零**
    `0000 0000` 代表 0。不像其他表示法，二補數系統中沒有「+0」和「-0」的區別，不會浪費任何一個位元組合。

3.  **表示範圍**
    對於一個 N 位元的二補數系統，它可以表示的數字範圍是：
    從 $-2^{N-1}$ 到 $2^{N-1} - 1$

    *   以 **4 位元** 為例 ($N=4$)，範圍是 $-2^{3}$ 到 $2^{3} - 1$，也就是從 **-8 到 +7**。
    *   以 **8 位元** 為例 ($N=8$)，範圍是 $-2^{7}$ 到 $2^{7} - 1$，也就是從 **-128 到 +127**。

    你會發現負數的範圍比正數多一個。這是因為正數包含 0，而那個最負的數 (例如 8 位元的 `1000 0000` = -128) 的二補數運算會得到它自己，這是一個特殊的邊界情況。

### 如何用硬體實現 A - B？

現在你知道了原理，我們就可以設計一個「加減法器」了。

我們需要計算 $A + (-B)$。而 $-B$ 就是 `(NOT B) + 1`。
所以，$A - B = A + (NOT B) + 1$。

看這個式子，我們需要做：
1.  把 B 的每個位元都變反相 (NOT B)。
2.  把 A、(NOT B)、和 1 這三樣東西加起來。

等等，一個全加器 (Full Adder) 不就是有三個輸入嗎？`a`, `b`, 和 `cin`！

我們可以這樣設計：
*   把 `A` 接到全加器們的 `a` 輸入。
*   把 `NOT B` 接到全加器們的 `b` 輸入。
*   把「初始進位 (`Cin`)」設定為 **1**！

這樣，我們就可以用完全相同的漣波進位加法器，只要在輸入端動一點手腳，就能同時處理加法和減法了！



上圖中，`Sub` 是一個控制訊號。
*   當 `Sub = 0` (做加法)，XOR 的作用像一個通路，B 會直接通過，`Cin` 也是 0。電路執行 $A + B + 0$。
*   當 `Sub = 1` (做減法)，XOR 會把 B 的每個位元反相 (因為 `B XOR 1 = NOT B`)，同時 `Cin` 也是 1。電路執行 $A + (NOT B) + 1$。

### 總結

1.  **二補數**是一種用二進位表示有號整數的聰明方法。
2.  它的**目的**是為了簡化硬體，讓**減法**可以透過**加法**電路來完成。
3.  求一個數的負數，方法是**「先變反相，再加一」**。
4.  利用這個特性，只要在加法器的輸入端加上一些控制邏輯 (例如 XOR 閘)，我們就能輕鬆打造出一個同時支援加法和減法的**算術邏輯單元 (ALU)** 的雛形。

這就是計算機結構中，軟體演算法 (二補數規則) 和硬體設計 (加法器電路) 完美結合的經典範例。是不是很優雅呢？

## Q: 能用上述 16 位元加法器，用 Verilog 建構出減法器嗎?

當然可以！這個問題非常好，完全展現了數位邏輯設計的精髓：**重複使用 (Reuse)** 和 **抽象化 (Abstraction)**。

我們不需要重新發明輪子去設計一個全新的減法器。既然我們已經有了一個功能強大的 `Adder_16bit` 模組，我們就要想辦法利用它來完成減法。

---

### 複習一下核心原理

我們剛剛學到，二補數讓減法可以變成加法：

$A - B = A + (-B)$

而 `-B` 的二補數表示法就是 `~B + 1` (先把 B 的所有位元反相，然後加 1)。

所以，整個減法運算可以寫成：

$A - B = A + (~B) + 1$

### 如何把這個公式對應到我們的 16 位元加法器？

我們的 `Adder_16bit` 模組長這樣：

```
+-----------------+
|                 |
|   Adder_16bit   |
|                 |
|   A[15:0]  >----+                 +---> Sum[15:0]
|                 |                 |
|   B[15:0]  >----o-----------------+
|                 |                 |
|      Cin   >----+                 +---> Cout
|                 |
+-----------------+
```

它有三個輸入：`A`, `B` 和 `Cin`。它會計算 `A + B + Cin`。

現在，我們把公式 $A + (~B) + 1$ 跟加法器的功能 `A + B + Cin` 對照一下：

*   公式中的 `A`  ->  可以直接連接到加法器的 `A` 輸入。
*   公式中的 `~B` ->  我們可以把輸入 `B` 的**每個位元都反相**後，再連接到加法器的 `B` 輸入。
*   公式中的 `+ 1` ->  這太完美了！我們只要把加法器的 `Cin` 輸入設定為 **1**，就可以實現這個 `+1` 的操作！

### Verilog 實作：建造 Subtractor_16bit 模組

現在，我們要來寫一個新的 Verilog 模組，就叫做 `Subtractor_16bit`。這個模組的內部會去「召喚」或「例化 (Instantiate)」一個我們之前做好的 `Adder_16bit` 來幫它完成工作。

```verilog
// 這是我們新的 16 位元減法器模組
module Subtractor_16bit(
    input  [15:0] A,          // 被減數
    input  [15:0] B,          // 減數
    output [15:0] Difference, // 差 A - B
    output        Borrow      // 借位旗標
);

    // 宣告一條內部線路，用來接收加法器的 Cout
    wire adder_cout;
    
    // 為了讓程式碼更清楚，我們可以宣告一條線路來代表 B 的反相
    wire [15:0] b_inverted;
    assign b_inverted = ~B; // ~ 是 Verilog 的位元反相 (NOT) 運算子

    // *** 核心部分：例化 (Instantiate) 一個 16 位元加法器 ***
    // 我們給這個被召喚出來的加法器取名叫 "subtraction_adder"
    Adder_16bit subtraction_adder (
        .A    (A),            // 減法器的 A 直接連到加法器的 A
        .B    (b_inverted),   // 減法器的 B *反相後* 連到加法器的 B
        .Cin  (1'b1),         // 將加法器的 Cin 固定設為 1，來完成 +1 的操作
        .Sum  (Difference),   // 加法器的 Sum 輸出就是我們的差 (Difference)
        .Cout (adder_cout)    // 將加法器的 Cout 連到內部線路
    );

    // 處理借位 (Borrow) 訊號
    // 在 A + (~B) + 1 運算中，如果 A >= B (無符號數)，則 Cout 會是 1 (無借位)
    // 如果 A < B (無符號數)，則 Cout 會是 0 (有借位)
    // 所以，Borrow 訊號正好是 Cout 的反相
    assign Borrow = ~adder_cout;

endmodule

// --- 為了讓這份程式碼可以獨立運作，我們把之前寫的模組也附在下面 ---

module Adder_16bit(
    input  [15:0] A,
    input  [15:0] B,
    input         Cin,
    output [15:0] Sum,
    output        Cout
);
    // 這裡我們直接用 Verilog 內建的加法運算子來寫，比較簡潔
    // 它跟我們用 for-loop 兜出來的漣波進位加法器，在功能上是等效的
    assign {Cout, Sum} = A + B + Cin;
endmodule

```

### 程式碼解說

1.  **模組定義**: 我們定義了一個新的 `Subtractor_16bit` 模組，它接收 `A` 和 `B`，輸出 `Difference` (差) 和 `Borrow` (借位)。
2.  **`assign b_inverted = ~B;`**: 我們用 `~` 運算子把 16 位元的輸入 `B` 的每一個位元都反相 (0 變 1，1 變 0)，並將結果存放在 `b_inverted` 這組線路中。
3.  **例化 `Adder_16bit`**: 這是最關鍵的一步。我們在 `Subtractor_16bit` 內部宣告了一個 `Adder_16bit` 的實例。這就像在一個大電路板上，焊上一個小晶片一樣。
4.  **`.A(A)`**: 把 `Subtractor_16bit` 的 `A` 輸入，連接到 `Adder_16bit` 實例的 `A` 輸入埠。
5.  **`.B(b_inverted)`**: 把我們剛剛算出的 `b_inverted` (`~B`)，連接到 `Adder_16bit` 實例的 `B` 輸入埠。
6.  **`.Cin(1'b1)`**: 這是實現二補數的魔法！我們直接把 `Adder_16bit` 實例的 `Cin` 輸入埠連接到一個常數 `1`。`1'b1` 是 Verilog 的語法，代表「1 位元的二進位數 1」。
7.  **`.Sum(Difference)`**: 把 `Adder_16bit` 實例的 `Sum` 輸出埠，連接到 `Subtractor_16bit` 的 `Difference` 輸出。加法器算出來的和，就是我們要的減法結果。
8.  **`assign Borrow = ~adder_cout;`**: 借位的邏輯剛好和加法器的進位相反。當不需要借位時 (例如 $5-3$)，加法器會產生進位；當需要借位時 (例如 $3-5$)，加法器不會產生進位。因此我們把加法器的 `Cout` 反相，作為減法器的 `Borrow` 輸出。

---

### 更進一步：打造一個「加減法器」

我們現在有了一個加法器和一個減法器。但其實它們內部用的核心元件都是同一個 `Adder_16bit`。在真實的 CPU 設計中，我們會把它們整合成一個單元，用一個控制訊號來決定現在要做加法還是減法。

我們可以設計一個 `AddSub_16bit` 模組，它有一個額外的輸入，叫做 `sub_enable`：
*   如果 `sub_enable = 0`，就執行加法 $A+B$。
*   如果 `sub_enable = 1`，就執行減法 $A-B$。

```verilog
module AddSub_16bit(
    input  [15:0] A,
    input  [15:0] B,
    input         sub_enable, // 0: add, 1: subtract
    output [15:0] Result,
    output        Overflow
);
    wire [15:0] b_operand;
    
    // 這裡用一個 XOR 閘來當作「可控制的反相器」
    // 當 sub_enable = 0, b_operand = B ^ 0 = B
    // 當 sub_enable = 1, b_operand = B ^ 1 = ~B
    assign b_operand = B ^ {16{sub_enable}}; // {16{...}} 是把 sub_enable 複製 16 次

    // Cin 也由 sub_enable 控制
    // 當 sub_enable = 0 (加法), Cin = 0
    // 當 sub_enable = 1 (減法), Cin = 1
    wire cin = sub_enable;

    // 我們只需要例化一次加法器！
    Adder_16bit the_unit (
        .A    (A),
        .B    (b_operand),
        .Cin  (cin),
        .Sum  (Result),
        .Cout () // Overflow 的計算比較複雜，我們先不接
    );
endmodule
```
這個 `AddSub_16bit` 模組，就是 CPU 裡面**算術邏輯單元 (ALU)** 最核心的原型了！

透過今天的練習，你已經掌握了如何從最底層的邏輯，一步步透過**模組化設計**和**重複使用**，建造出更複雜、更強大的電路。這是資工系硬體課程最重要的核心思想之一！

## Q: ALU 是什麼？

這是一個絕佳的問題！我們剛剛從最小的積木 (`FullAdder`)，蓋出了一個功能單元 (`AddSub_16bit`)。現在我們要問：這個功能單元在電腦裡，是放在哪個更大的部門底下呢？

答案就是 **ALU (Arithmetic Logic Unit)**，中文叫做「**算術邏輯單元**」。

---

### ALU 是什麼？CPU 的大腦核心

如果說 CPU (中央處理器) 是電腦的**大腦**，那麼 ALU 就是這個大腦中負責**思考和計算**的核心區域。你可以把它想像成一個功能超級強大的計算機。

> **ALU (算術邏輯單元)** 是 CPU 內部的一個數位電路，負責執行所有**整數的算術運算**和**邏輯運算**。

基本上，CPU 收到的任何計算指令，最終都會交給 ALU 來處理。你寫的程式碼 `c = a + b;`，編譯後就會變成一個指令，告訴 CPU：「嘿，把 `a` 和 `b` 這兩個數字送到 ALU，讓它做加法，然後把結果存到 `c`」。

### ALU 的兩大核心業務

光看名字 "Arithmetic Logic Unit"，我們就可以把它拆成兩大塊業務：

#### 1. 算術運算 (Arithmetic Operations)

這是我們最熟悉的部分。ALU 負責所有跟數學計算相關的工作，例如：

*   **加法 (Add)**: `A + B`
*   **減法 (Subtract)**: `A - B`
*   **加一 (Increment)**: `A + 1` (這在迴圈計數中非常常用)
*   **減一 (Decrement)**: `A - 1`
*   **取負數 (Negate)**: `-A` (其實就是計算 `0 - A`)

我們之前設計的 `AddSub_16bit` 模組，其實就是 ALU 算術部門的一個迷你原型！

#### 2. 邏輯運算 (Logic Operations)

這是 ALU 的另一項關鍵業務。邏輯運算不像加減法那樣改變數值的大小，而是對數字的**每一個位元** (bit) 進行獨立的布林代數操作。這在程式設計中對於資料處理、位元操作極其重要。

常見的邏輯運算有：

*   **AND (及)**: `A & B`
    *   常用於「**遮罩 (Masking)**」，例如我只想看某個數字的低 8 位，就可以把它和 `0x00FF` (`...000011111111`) 做 AND 運算。
*   **OR (或)**: `A | B`
    *   常用於「**設定位元 (Setting bits)**」，例如我想把某個數字的第 3 個位元設為 1，就可以把它和 `0x0008` (`...00001000`) 做 OR 運算。
*   **XOR (互斥或)**: `A ^ B`
    *   常用於「**翻轉位元 (Flipping bits)**」或檢查兩個數是否相等。
*   **NOT (反相)**: `~A`
    *   把所有位元的 0 變 1，1 變 0。

**範例 (4 位元):**
假設 `A = 1010`，`B = 1100`
*   `A AND B` = `1000` (只有兩個位元都是 1 的地方，結果才是 1)
*   `A OR B`  = `1110` (只要有任何一個位元是 1，結果就是 1)
*   `A XOR B` = `0110` (只有當兩個位元不同時，結果才是 1)

### ALU 的運作方式：靠「指令」決定工作

ALU 內部有這麼多功能（加、減、AND、OR...），它怎麼知道這次該做哪一件呢？

答案是：靠一個**控制訊號**，我們通常稱之為 **操作碼 (OpCode)** 或**選擇訊號 (Select Signal)**。

CPU 的**控制單元 (Control Unit)** 會根據目前正在執行的指令，發送一個對應的 OpCode 給 ALU。ALU 就像一個聽話的員工，看到 OpCode 就知道要做什麼工作。

| OpCode (範例) | ALU 執行操作 |
| :-------------: | :---------------- |
|      0000       | `Result = A + B`  |
|      0001       | `Result = A - B`  |
|      0010       | `Result = A + 1`  |
|      ...        | ...               |
|      1000       | `Result = A AND B`|
|      1001       | `Result = A OR B` |
|      1010       | `Result = NOT A`  |

硬體上，這個 OpCode 會去控制一個叫做「**多工器 (Multiplexer, MUX)**」的電路。MUX 就像一個電子開關，它會根據 OpCode，從眾多運算結果中（加法器的結果、AND 閘的結果、OR 閘的結果...），選擇**正確的那一個**作為 ALU 的最終輸出。



### ALU 不只給結果，還給「狀態」：旗標 (Flags)

ALU 完成計算後，除了給出主要的`Result`，通常還會更新一組特殊的位元，叫做**旗標 (Flags)** 或**狀態碼 (Status Codes)**。這些旗標描述了剛剛運算結果的「特性」，對於程式的流程控制（例如 `if` 判斷）至關重要。

最常見的四個旗標是：

1.  **零旗標 (Zero Flag, Z)**: 如果運算結果**是 0**，這個旗標就設為 1。 (用於判斷 `if (a == b)`)
2.  **負旗標 (Negative Flag, N)**: 如果運算結果是**負數**（也就是 MSB 是 1），這個旗標就設為 1。 (用於判斷 `if (result < 0)`)
3.  **進位旗標 (Carry Flag, C)**: 如果**無號數**加法產生了進位（溢位），這個旗標就設為 1。 (用於更大位數的運算)
4.  **溢位旗標 (Overflow Flag, V)**: 如果**有號數**運算結果超出了表示範圍，這個旗標就設為 1。 (例如 8 位元系統中，`100 + 50` 得到負數，就是溢位)

### 簡化的 16 位元 ALU Verilog 範例

我們來看看一個非常簡化的 ALU 在 Verilog 中可能長什麼樣子。它整合了我們之前的 `AddSub` 概念，並加入了邏輯運算。

```verilog
module Simple_ALU_16bit(
    input  [15:0] A,
    input  [15:0] B,
    input  [3:0]  OpCode,     // 4位元的操作碼，可以定義 2^4 = 16 種操作
    output reg [15:0] Result, // ALU 的運算結果 (用 reg 因為在 always block 中賦值)
    output reg    Zero_Flag   // 零旗標
);

    // 我們需要一個加減法單元來處理算術運算
    wire [15:0] adder_sum;
    wire add_sub_cin = (OpCode == 4'b0001); // 只有減法時 Cin 為 1
    wire [15:0] b_operand = (OpCode == 4'b0001) ? ~B : B; // 只有減法時 B 反相

    // 例化一個加法器
    // 為了簡化，我們假設所有算術運算都基於這個加法器
    assign adder_sum = A + b_operand + add_sub_cin;

    // always @(*) 是一個組合邏輯的描述方式
    // 代表任何輸入 (A, B, OpCode) 改變時，就重新計算一次
    always @(*) begin
        // 根據 OpCode 決定 Result 是什麼
        case (OpCode)
            4'b0000: Result = adder_sum;        // 0: A + B
            4'b0001: Result = adder_sum;        // 1: A - B
            4'b1000: Result = A & B;            // 8: A AND B
            4'b1001: Result = A | B;            // 9: A OR B
            4'b1010: Result = A ^ B;            // 10: A XOR B
            4'b1011: Result = ~A;               // 11: NOT A
            default: Result = 16'h0000;         // 其他未定義的 OpCode，輸出 0
        endcase
    end

    // 計算 Zero Flag：如果 Result 的所有位元都是 0，則為 1
    always @(*) begin
        if (Result == 16'h0000) begin
            Zero_Flag = 1'b1;
        end else begin
            Zero_Flag = 1'b0;
        end
        // 更簡潔的寫法: assign Zero_Flag = (Result == 16'h0000);
    end

endmodule
```

### 總結

1.  **ALU** 是 CPU 的**核心計算單元**。
2.  它負責執行**算術運算**（加、減等）和**邏輯運算**（AND, OR, NOT 等）。
3.  它接收資料輸入 (`A`, `B`) 和一個**操作碼 (OpCode)**，OpCode 告訴 ALU 這次要做哪種運算。
4.  運算完畢後，它會輸出一個**結果 (Result)** 和一組**旗標 (Flags)**，用來描述結果的狀態。

從邏輯閘到加法器，再到加減法器，最終到 ALU，你已經一步步地走進了 CPU 的核心。這條路徑，就是計算機結構這門課最迷人的地方！

