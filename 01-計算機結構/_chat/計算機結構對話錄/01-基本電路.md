# 基本電路

* [AI對話](https://aistudio.google.com/app/prompts?state=%7B%22ids%22:%5B%221UZw6-XJQ9H89XGG_IdW-BSrTIz26DTcr%22%5D,%22action%22:%22open%22,%22userId%22:%22111605452542833299008%22,%22resourceKeys%22:%7B%7D%7D&usp=sharing)

## Q: 數位邏輯是什麼？

好的，同學，歡迎來到資工系！這是一個充滿挑戰與樂趣的領域。我是你的「數位邏輯」與「計算機結構」老師，我的任務就是帶你一步步地揭開電腦世界的神秘面紗。

很多同學剛進來，可能覺得寫程式、寫軟體就是資工的全部。但這就像只看到冰山的一角。那些酷炫的軟體、遊戲、App，究竟是怎麼在冷冰冰的硬體上跑起來的？這兩門課，就是要帶你探索冰山底下的巨大世界。

我們先從「數位邏輯」開始。

---

### 數位邏輯 (Digital Logic)：電腦世界的「樂高積木」

#### 什麼是「數位」？

想像一下電燈的開關，它只有兩種狀態：「開」或「關」。電腦的世界也是這樣，它只認識兩種東西：**0** 和 **1**。

*   **0**：可以想成是「關」、「低電位」、「假 (False)」。
*   **1**：可以想成是「開」、「高電位」、「真 (True)」。

這種用 0 和 1 來表示一切資訊的方式，就叫做「數位」(Digital)。你的照片、看的影片、聽的音樂、寫的程式碼，在電腦底層全都是一大長串的 0 和 1。

#### 什麼是「邏輯」？

「邏輯」聽起來很玄，但其實就是**做決策的規則**。

舉個日常生活的例子：
> **如果** 今天「下雨」**而且**「我帶了傘」，**那麼** 我就「不會淋濕」。

這就是一個邏輯判斷。在數位邏輯中，我們用一個叫做「邏輯閘」(Logic Gate) 的東西來實現這種判斷。邏輯閘是數位電路最最基本的單位，就像是蓋房子的磚塊，或是玩樂高的積木。

#### 認識最基本的三塊「樂高積木」

我們來認識三個最基本，也最重要的邏輯閘：**AND**、**OR**、**NOT**。

1.  **AND 閘 (而且)**
    *   **規則**：所有條件都必須是「真 (1)」，結果才會是「真 (1)」。
    *   **比喻**：想像一個需要兩把鑰匙才能打開的保險箱。你 (`A`) 有一把，你的朋友 (`B`) 有一把。必須**你** `AND` **你的朋友**同時轉動鑰匙，保險箱 (`Z`) 才會打開。
    *   **真值表 (Truth Table)**：

| 輸入 A | 輸入 B | 輸出 Z |
| :---: | :---: | :---: |
|   0   |   0   |   0   |
|   0   |   1   |   0   |
|   1   |   0   |   0   |
|   1   |   1   |   1   |

2.  **OR 閘 (或者)**
    *   **規則**：只要有任何一個條件是「真 (1)」，結果就是「真 (1)」。
    *   **比喻**：家裡的前門 (`A`) 和後門 (`B`) 都有門鈴。只要**前門** `OR` **後門**的門鈴被按，屋內的鈴聲 (`Z`) 就會響。
    *   **真值表**：

| 輸入 A | 輸入 B | 輸出 Z |
| :---: | :---: | :---: |
|   0   |   0   |   0   |
|   0   |   1   |   1   |
|   1   |   0   |   1   |
|   1   |   1   |   1   |

3.  **NOT 閘 (反轉)**
    *   **規則**：把結果整個顛倒過來。「真 (1)」變「假 (0)」，「假 (0)」變「真 (1)」。
    *   **比喻**：這就像一個「天生反骨」的開關。你按下開 (`A=1`)，它反而把燈關掉 (`Z=0`)；你放開 (`A=0`)，它反而把燈打開 (`Z=1`)。
    *   **真值表**：

| 輸入 A | 輸出 Z |
| :---: | :---: |
|   0   |   1   |
|   1   |   0   |

#### 數位邏輯到底在學什麼？

數位邏輯這門課，就是教你如何：

1.  **理解這些基本的邏輯閘。**
2.  **將這些邏輯閘組合起來，像堆樂高一樣，打造出更複雜的功能。**

例如，我們可以組合這些邏輯閘來做出一個「加法器」，讓電腦學會 $1+1=2$。我們還可以做出「記憶體」，讓電腦可以儲存資料。當無數個這些小功能被組合在一起，最終就構成了電腦最核心的大腦——**中央處理器 (CPU)**。

所以，數位邏輯是我們理解硬體世界的「語言」。它告訴我們，電腦是如何從最底層的 0 和 1，一步步搭建出能夠執行複雜運算能力的。

---

#### 接下來呢？

當你掌握了這些基本的「樂高積木」和組合規則後，下一堂課我們就會進入「計算機結構」。那將會告訴你，我們是如何將這些加法器、記憶體等零件，組織成一台完整、有效率的電腦。

別擔心，這一切聽起來可能有點抽象，但我們會一步步從最簡單的例子開始。這趟旅程的目標，是讓你未來在寫程式時，心中不只有程式碼，更能看透程式碼底下，硬體是如何為你奔波運作的。這會讓你成為一個更優秀的資工人才。

有任何問題，隨時都可以提出來！

## Q: 那數位邏輯和計算機結構有什麼關係？

問得非常好！這個問題可以說是整個資工系硬體課程的核心。如果搞懂了它們的關係，你對電腦世界的理解就會立刻清晰起來。

延續我們剛剛的樂高比喻：

> 如果說「**數位邏輯**」是教你如何製造每一塊樂高積木，像是 2x1 的、4x2 的、有輪子的、透明的...
>
> 那麼「**計算機結構**」就是教你如何看懂藍圖，並用這些積木蓋出一座宏偉的樂高城堡（例如：千年鷹號）。

讓我更詳細地說明這兩者的分工與合作關係。

---

### 一、專注的層級不同

*   **數位邏輯 (Digital Logic)**：**專注在「零件」層級**
    *   它回答的問題是：「這個零件是**什麼**？它**如何運作**？」
    *   我們在這裡打造的是電腦最基本的**功能單元 (Functional Units)**。
    *   例如：
        *   如何用 AND、OR、NOT 閘兜出一個可以做加法的「加法器 (Adder)」？
        *   如何做出一個可以暫時儲存 1 bit 資料的「正反器 (Flip-Flop)」？
        *   如何將很多正反器組合成一個可以儲存 32 bits 資料的「暫存器 (Register)」？

*   **計算機結構 (Computer Architecture)**：**專注在「系統」層級**
    *   它回答的問題是：「我們該**如何組織**這些零件，讓它們**有效率地協同工作**，來完成一個複雜的任務（例如：執行程式）？」
    *   我們在這裡思考的是整個電腦的**設計藍圖與規範**。
    *   例如：
        *   CPU 應該包含哪些核心零件？（例如：算術邏輯單元 ALU、控制單元 Control Unit、暫存器組 Register File）
        *   CPU 要如何去記憶體 (Memory) 拿資料和指令？拿資料的路線（我們叫「資料路徑 Datapath」）該怎麼鋪設最快？
        *   該如何設計一套「指令集 (Instruction Set)」，讓軟體（程式設計師）可以跟硬體（CPU）溝通？
        *   為了讓電腦快還要更快，我們是不是可以加入「快取 (Cache)」或「管線化 (Pipelining)」這種高階設計？

### 二、我們來蓋一台簡單的電腦，看看這兩門課怎麼分工合作：

假設我們的目標是蓋一台能執行 `c = a + b` 這個指令的電腦。

1.  **【數位邏輯的工作】打造零件**
    *   **任務**：我們需要一個能做加法的東西。
    *   **成品**：數位邏輯專家利用一堆邏輯閘，設計並打造出一個「32位元加法器」。這個加法器有兩個 32 位元的輸入 (input A, input B) 和一個 32 位元的輸出 (output Sum)。
    *   **任務**：我們需要地方存放 `a`、`b`、`c` 這些數字。
    *   **成品**：數位邏輯專家利用正反器，打造出好幾個「32位元暫存器」。

2.  **【計算機結構的工作】組織零件與制定規則**
    *   **任務**：怎麼讓加法器和暫存器合作，去執行 `c = a + b`？
    *   **成品**：計算機結構的專家（我們叫他們「架構師」）就出場了。他會畫出設計藍圖：
        *   **定義指令格式**：他決定 `add c, a, b` 這個指令，在電腦底層要用 `000010...` 這樣的 0/1 序列來表示。這就是**指令集架構 (ISA)** 的一部分。
        *   **設計資料路徑 (Datapath)**：他會規劃出電線要怎麼連，讓 `a` 和 `b` 暫存器裡的資料，可以順利地流到加法器的輸入端。
        *   **設計控制單元 (Control Unit)**：他會設計一個「大腦」，這個大腦在看到 `000010...` 這串指令時，就會發出信號，指揮資料路徑：「喂！現在把 a 和 b 的資料送去加法器，然後把加完的結果存回 c 暫存器！」

### 三、關係總結

| 項目 | 數位邏輯 (Digital Logic) | 計算機結構 (Computer Architecture) |
| :--- | :--- | :--- |
| **核心問題** | 這個零件怎麼**做**出來？ | 這個系統怎麼**組織**起來最高效？ |
| **抽象層級** | 低階 (Low-Level) | 高階 (High-Level) |
| **基本單位** | 邏輯閘 (Logic Gates) | 功能單元 (ALU, Registers, Memory) |
| **產出範例** | 加法器、多工器、解碼器、暫存器 | 資料路徑、控制單元、快取、指令集 |
| **最終目標** | 打造出可靠的功能**元件** | 設計出高效能的完整**電腦** |
| **樂高比喻** | 製造各種形狀的**樂高積木** | 繪製並理解**樂高城堡的設計藍圖** |

---

#### 對你來說，這意味著什麼？

身為一個資工系的學生，你未來主要是寫軟體。但理解這兩門課的關係至關重要：

*   **數位邏輯** 讓你了解電腦運算的**物理極限**與**本質**。
*   **計算機結構** 則讓你明白，你寫的程式碼（例如 `a+b`）是如何被翻譯成硬體能夠理解的指令，並在精心設計的電路中飛速執行的。這也是為什麼有些寫法效能高，有些寫法效能差的根本原因。

總結來說，**數位邏輯是「打地基」，計算機結構是「蓋大樓」**。地基不穩，大樓蓋不起來；沒有好的設計圖，蓋出來的大樓也只是零件的混亂堆砌。兩者缺一不可，共同構成了我們今天所依賴的強大電腦。

準備好開始動手設計我們第一個數位邏輯電路了嗎？

## Q: CPU 是怎麼運作的？

這是一個絕佳的問題！我們已經知道了「零件」（數位邏輯）和「藍圖」（計算機結構），現在我們就來看看這座宏偉的城堡——**CPU (Central Processing Unit, 中央處理器)**——是如何運作的。

CPU 是電腦的心臟與大腦。它的本質其實非常單純：它是一台**極度快速、但很笨、絕對服從的指令執行機器**。你叫它做什麼，它就做什麼，而且做得飛快。

為了理解它，我們先用一個生動的比喻：**把 CPU 想像成一個在廚房裡忙碌的廚師**。

---

### CPU 廚房裡的關鍵角色

這個廚房裡有幾個關鍵的東西：

1.  **廚師本人 (CPU)**：他負責執行所有任務，但他自己記性不好，一次只能專心做一件事。
2.  **食譜 (Program / 程式)**：放在廚房外面的大書櫃（**記憶體 RAM**）裡，上面寫著一道道菜的步驟（指令）。
3.  **料理台 (Registers / 暫存器)**：廚師手邊一小塊區域，可以暫時放正在處理的食材（資料）。這裡空間很小，但拿取速度飛快。
4.  **廚具 (ALU / 算術邏輯單元)**：像是菜刀、果汁機、烤箱。專門用來對食材進行加工（加、減、乘、除、比較大小等）。這是用我們在數位邏輯課學的邏輯閘打造出來的。
5.  **廚房總管 (Control Unit / 控制單元)**：廚師的大腦。他負責看食譜，然後指揮廚師的雙手和廚具該做什麼。

### CPU 的核心工作流程：取餐、備餐、上菜循環

CPU 的一生，就是不斷重複一個簡單的循環，我們稱為「**指令週期 (Instruction Cycle)**」。就像廚師做菜一樣，可以分為三個（有時是四個）主要步驟：

1.  **提取 (Fetch)**：去拿下一步的指令。
2.  **解碼 (Decode)**：看懂指令到底要做什麼。
3.  **執行 (Execute)**：實際動手完成指令。
4.  **(寫回, Write-back)**：將結果放回指定的地方。

---

#### 讓我們用一個具體的例子來走一遍流程

假設我們的程式有一行指令，要做的是 `c = a + b`。
假設 `a` 的值是 5，`b` 的值是 10。
在 CPU 的世界裡，這會被翻譯成類似這樣的指令：
`add R3, R1, R2` (把暫存器 R1 和 R2 的值相加，結果存到暫存器 R3)

**準備工作：**
*   程式（食譜）已經被載入到記憶體 (RAM) 中。
*   資料 `a=5` 存放在暫存器 `R1`，`b=10` 存放在暫存器 `R2`。

**循環開始！**

#### 1. 提取 (Fetch) 階段

*   **廚房比喻**：廚師（CPU）問總管（控制單元）：「下一步要做什麼？」總管查看食譜（RAM）上標示的當前頁數（一個叫**程式計數器 Program Counter, PC** 的特殊暫存器），然後把 `add R3, R1, R2` 這行指令拿給廚師。
*   **CPU 內部**：
    1.  控制單元 (CU) 查看程式計數器 (PC) 的位址。
    2.  CU 命令記憶體，把 PC 指向的那個位址上的指令 (`add R3, R1, R2` 的 0/1 機器碼) 傳送過來。
    3.  指令被載入到 CPU 內部的「指令暫存器 (Instruction Register, IR)」。
    4.  PC 自動指向下一條指令的位址，準備下一次的提取。

> **流程：** `PC` -> `記憶體` -> `CPU的指令暫存器`

#### 2. 解碼 (Decode) 階段

*   **廚房比喻**：廚師看著手上的指令 `add R3, R1, R2`。總管（控制單元）立刻解析出這條指令的意圖：「喔！這是一個**加法**指令。我們需要用到**料理台**上的 `R1` 和 `R2` 這兩個碗裡的食材，還需要用到**果汁機**（加法器），最後把成品放到 `R3` 這個新碗裡。」
*   **CPU 內部**：
    1.  控制單元 (CU) 的解碼電路分析指令暫存器裡的 0/1 機器碼。
    2.  它辨識出這是一個 `add` 操作。
    3.  它確認了需要讀取 `R1` 和 `R2` 兩個來源暫存器，以及需要寫入 `R3` 這個目標暫存器。
    4.  CU 開始發出各種控制信號，就像打開高速公路的各個閘門，準備好資料要流動的路徑。

#### 3. 執行 (Execute) 階段

*   **廚房比喻**：總管一聲令下！廚師的雙手立刻動作：
    1.  從料理台（暫存器）上拿起 `R1` 碗裡的 5 和 `R2` 碗裡的 10。
    2.  把它們一起倒進果汁機（ALU）。
    3.  按下「加法」按鈕。
    4.  果汁機（ALU）運算出結果 15。
*   **CPU 內部**：
    1.  CU 發出信號，將暫存器 `R1` (值為5) 和 `R2` (值為10) 的內容送進算術邏輯單元 (ALU)。
    2.  CU 同時也告訴 ALU，這次要執行的是「加法」運算。
    3.  ALU (由我們學的數位邏輯閘組成) 計算出 $5 + 10 = 15$。

#### 4. 寫回 (Write-back) 階段

*   **廚房比喻**：廚師把果汁機裡算好的結果 15，倒進料理台上一個乾淨的碗 `R3` 裡。至此，這道指令就算完成了。
*   **CPU 內部**：
    1.  ALU 計算出的結果 15，被傳送到目標暫存器 `R3`。
    2.  CU 發出信號，將 15 寫入 `R3`。

**任務完成！** CPU 馬上又回到第一步「提取」，去拿下一條指令，週而復始。

---

### 總結

所以，CPU 的運作本質上就是一場**極其精密的電子訊號接力賽**。

`取指令 -> 解碼 -> 執行 -> 存結果`

這個循環發生得有多快呢？如果你電腦的 CPU 時脈是 4.0 GHz，這意味著這個循環**每秒鐘可以發生四十億次**！

正是這種驚人的速度，讓一個只會做簡單事的「笨蛋」，能夠執行複雜的作業系統、跑 3A 遊戲大作、播放高畫質影片，創造出我們所看到的數位世界的魔法。

理解了這個基礎流程後，我們在「計算機結構」這門課中，就會繼續探討：如何讓這個流程跑得**更快**、**更有效率**？例如，我們能不能在執行第一道菜的同時，就先去拿第二道菜的食譜？（這就是**管線化 Pipelining** 的概念），這就是後續課程的精彩之處了。

## Q: Verilog 是什麼？

當然！既然我們已經了解了數位邏輯的「零件」和計算機結構的「藍圖」，你心中一定會有個疑問：

> 「難道現在設計 CPU，還是工程師們拿著烙鐵，一個一個把上億個邏輯閘焊在電路板上嗎？」

答案當然是否定的！那樣太沒效率了。為了解決這個問題，我們需要一種更聰明、更抽象的方法來**描述**我們想要的硬體電路。這，就是 **Verilog** 登場的時刻。

---

### Verilog 是什麼？

**Verilog** 是一種 **硬體描述語言 (Hardware Description Language, HDL)**。

請注意這個名字，它不是「程式語言」(Programming Language)，而是「**硬體描述語言**」。這是一切關鍵的所在。

*   **程式語言 (如 Python, C++)**：你寫的是**一系列要依序執行的指令**。它的思維是「先做第一步，再做第二步...」。
*   **硬體描述語言 (如 Verilog)**：你寫的是**對一個電路的結構與行為的描述**。它的思維是「這裡有一個零件，它有哪些接腳，它的功能是什麼」。所有的事情都是**同時發生**的，就像真實的電路一樣。

簡單來說：
> **Verilog 就是硬體工程師用來畫「數位電路設計圖」的文字工具。**

我們不再用手畫邏輯閘的圖，而是用寫程式碼的方式來「描述」這個電路長什麼樣子、應該怎麼運作。

#### 為什麼要用 Verilog？

1.  **處理複雜度**：一顆現代 CPU 有數十億個電晶體（邏輯閘）。用手畫圖根本不可能。用文字描述，我們可以像寫文章一樣，有結構、有模組地設計。
2.  **模擬與驗證 (Simulation)**：在花費數百萬美金去製造一顆晶片（這個過程叫「下線 (Tape-out)」）之前，我們可以用軟體去「跑」我們的 Verilog 程式碼，看看設計出來的電路行為是否正確。這就像蓋大樓前，先用 3D 模型模擬一次，確保沒有設計錯誤。
3.  **自動化合成 (Synthesis)**：這是最神奇的一步。我們可以把寫好的 Verilog 程式碼，餵給一個叫做「合成器 (Synthesizer)」的特殊軟體。這個軟體會自動把你的文字描述，**翻譯**成由真實邏輯閘（AND, OR, NOT...）組成的電路連接圖（我們稱為「網表 Netlist」）。

**Verilog 的整個流程就像這樣：**

`你的想法` -> `寫成 Verilog 程式碼` -> `用軟體模擬驗證` -> `用合成器轉成邏輯閘電路` -> `製造出實體晶片`

---

### 第一個 Verilog 程式示範：描述一個 AND 閘

我們來看看用 Verilog 描述一個我們最熟悉的 AND 閘會是什麼樣子。

**目標**：我們要描述一個有兩個輸入 (`a`, `b`) 和一個輸出 (`z`) 的 AND 閘。它的邏輯是 $z = a \ \& \ b$。

```verilog
// 模組宣告：定義一個叫做 "simple_and_gate" 的新零件
module simple_and_gate (
    // 端口列表：定義這個零件有哪些對外的接腳
    input  wire a,  // 一個名叫 a 的輸入接腳
    input  wire b,  // 一個名叫 b 的輸入接腳
    output wire z   // 一個名叫 z 的輸出接腳
);

    // 描述行為：定義這個零件內部的邏輯
    // "assign" 的意思是 z 這個輸出的信號 "持續地" 由 a & b 的結果決定
    assign z = a & b;

// 模組結束
endmodule
```

#### 程式碼解說：

*   `module simple_and_gate (...)` / `endmodule`：
    這是在定義一個「模組」，你可以把它想像成在設計一個**獨立的樂高積木**。我們給這塊積木取名叫 `simple_and_gate`。
*   `input wire a, input wire b`：
    定義了這塊積木有兩個「輸入插孔」，分別叫做 `a` 和 `b`。`wire` 表示這些是電線。
*   `output wire z`：
    定義了這塊積木有一個「輸出突點」，叫做 `z`。
*   `assign z = a & b;`：
    這是核心！這行程式碼**不是**一個步驟，而是一個**宣告**。它描述了一個永恆不變的物理事實：「`z` 這個點的電壓，永遠等於 `a` 點的電壓和 `b` 點的電壓進行 AND 運算的結果」。
    *   `&` 是 Verilog 中代表 AND 運算的符號。
    *   只要 `a` 或 `b` 的信號一有變化，`z` 的結果**立刻**就會跟著改變，就像真實的電路一樣，這就是所謂的**並行 (Concurrent)** 特性。

#### Verilog 和傳統程式語言的思維差異

假設在 Verilog 裡你寫了兩行：

```verilog
assign z1 = a & b;
assign z2 = c | d; // | 是 OR 的意思
```

在 Verilog 的世界裡，`z1` 和 `z2` 的計算是**同時發生**的。因為它們是兩個獨立的電路，電路是同時通電運作的。

但如果在 Python 裡你寫：

```python
z1 = a and b
z2 = c or d
```

Python 會**先**算完 `z1`，**然後才**去算 `z2`。這是**循序 (Sequential)** 的。

---

### 總結

Verilog 是連接「抽象的數位邏輯概念」與「實體的硬體電路」之間的橋樑。

*   我們用它來**描述**硬體，而不是命令電腦做事。
*   它的核心思維是**並行**的，所有描述的電路都是同時運作的。
*   學會 Verilog，你就擁有了設計 CPU、GPU 等各種數位晶片的超能力！

接下來，我們會學習如何用 Verilog 把這些小的邏輯閘「積木」，組合成更複雜的電路，比如我們之前提到的「加法器」。

## Q: 接下來請用 Verilog 區塊式語法，透過類似積木的方式，組合出我所說的電路。首先請使用 nand 為基本元件，建構出 and, or, not

太棒了！這正是數位邏輯最核心、最有趣的精髓所在。我們要做的這件事，完美地展示了數位世界的「化繁為簡」哲學。

在數位邏輯中有一個非常漂亮的概念叫做「**功能完備性 (Functional Completeness)**」。它的意思是，你只需要一種邏輯閘，就能夠打造出其他**所有**的邏輯閘。而 **NAND** 閘（和 NOR 閘）就是這樣一個「萬能」的基礎元件。

今天，我們就要親手證明這件事。我們的規則是：
1.  我們手上只有無限量的 2 輸入 NAND 閘。
2.  禁止直接使用 Verilog 裡的 `&` (AND), `|` (OR), `~` (NOT) 運算子。
3.  我們將用「**模組實例化 (Module Instantiation)**」的方式，也就是你說的「組合積木」，來完成這個任務。

---

### 第 1 步：定義我們的「基本積木」- 2 輸入 NAND 閘

首先，我們要先定義好我們唯一能使用的那塊「樂高積木」。我們來寫一個叫做 `nand_gate` 的模組。從現在開始，這就是我們宇宙的原子，是我們唯一可以使用的東西。

```verilog
// ==========================================================
// 我們的基本積木：一個 2 輸入的 NAND 閘
// 功能: z = NOT(a AND b)
// ==========================================================
module nand_gate (
    input  wire a,
    input  wire b,
    output wire z
);

    // 在這個最底層的模組中，我們可以使用 Verilog 的基本運算子
    // 來 "定義" 這個積木的物理行為。
    // ~ 是 NOT, & 是 AND
    assign z = ~(a & b);

endmodule
```

好了！我們已經設計好了我們的「萬能積木」。現在，讓我們把它放進零件盒，開始組合吧！

---

### 第 2 步：用 NAND 組合出 NOT

**思考邏輯：**
一個 NAND 閘的功能是 `NOT (a AND b)`。我怎麼樣讓它變成單純的 `NOT (a)` 呢？
根據布林代數，`a AND a` 的結果就是 `a`。所以，如果我把 NAND 閘的兩個輸入 (`a` 和 `b`) 全部都接上同一個信號源 `in`，那它的輸出就會是 `NOT (in AND in)`，也就是 `NOT (in)`。

**電路圖：**


**Verilog 實作：**
我們來蓋一個新模組 `my_not_gate`。它裡面**只**能包含我們剛剛做好的 `nand_gate` 積木。

```verilog
// ==========================================================
// 我們的第一個作品：用 NAND 積木打造 NOT 閘
// 功能: out = NOT(in)
// ==========================================================
module my_not_gate (
    input  wire in,
    output wire out
);

    // "實例化" 一個 nand_gate 積木
    // 語法: 積木的類型 積木的名字 (.積木的接腳(要連接的電線));
    nand_gate U1 (
        .a(in),   // 把我們 nand_gate 積木的 a 接腳，接到 my_not_gate 的 in 電線上
        .b(in),   // 同時，也把 b 接腳，接到 my_not_gate 的 in 電線上
        .z(out)   // 最後，把 nand_gate 積木的 z 輸出，接到 my_not_gate 的 out 電線上
    );

endmodule
```
**解說：**
`nand_gate U1 (...)` 這段程式碼，就好像你從零件盒裡拿出一個 `nand_gate` 積木，把它命名為 `U1` (Unit 1)，然後開始接線。我們把 `U1` 的兩個輸入腳 `.a` 和 `.b` 都焊接到 `my_not_gate` 模組的輸入電線 `in` 上，再把 `U1` 的輸出腳 `.z` 焊接到 `my_not_gate` 的輸出電線 `out` 上。

成功！我們只用 NAND 就做出了 NOT。

---

### 第 3 步：用 NAND 組合出 AND

**思考邏輯：**
我們手上有的 NAND 是 `NOT (a AND b)`。而我們想要的 AND 是 `a AND b`。
這兩者之間不就只差了一個 `NOT` 嗎？
所以，只要我們在 NAND 閘的後面，再接上一個 NOT 閘，結果就是 `NOT ( NOT (a AND b) )`。兩個 NOT 會互相抵消，就得到了 `a AND b`！
而我們剛剛已經用 NAND 做出了 `my_not_gate`，正好可以派上用場。

**電路圖：**


**Verilog 實作：**
現在，我們的 `my_and_gate` 模組需要兩塊 `nand_gate` 積木。

```verilog
// ==========================================================
// 第二個作品：用 NAND 積木打造 AND 閘
// 功能: z = a AND b
// ==========================================================
module my_and_gate (
    input  wire a,
    input  wire b,
    output wire z
);

    // 我們需要一條內部的電線，來連接第一個積木的輸出和第二個積木的輸入
    wire nand_output_wire;

    // 第一個積木 (NAND): 計算 a NAND b
    nand_gate U1 (
        .a(a),
        .b(b),
        .z(nand_output_wire) // 結果先送到內部電線
    );

    // 第二個積木 (當作 NOT 使用): 把剛剛的結果反轉
    // 這裡我們直接使用剛剛設計好的 my_not_gate 模組，這就是模組化的威力！
    my_not_gate U2 (
        .in(nand_output_wire), // 輸入來自第一個積木的結果
        .out(z)                // 輸出就是我們最終的結果
    );

endmodule
```
**解說：**
看到 `wire nand_output_wire;` 了嗎？這是在我們的模組內部宣告一條「隱藏的電線」，它不對外連接。它的作用就像是樂高模型內部，你看不到的那些連接桿，專門用來串接內部的兩個零件。

`U1` 負責產生 `a NAND b` 的結果，並把它送到 `nand_output_wire` 上。
`U2` (我們的 `my_not_gate`) 接收這條線上的信號，再做一次 NOT 運算，就得到了最終的 AND 結果，並送到輸出 `z`。

---

### 第 4 步：用 NAND 組合出 OR

**思考邏輯：**
這是最需要動腦筋的一個，需要用到數位邏輯的聖杯——**笛摩根定律 (De Morgan's Laws)**。
其中一條定律是： $a \ OR \ b = NOT \ ( \ (NOT \ a) \ AND \ (NOT \ b) \ )$
把右邊的式子翻譯成 NAND 的語言就是： $a \ OR \ b = (NOT \ a) \ NAND \ (NOT \ b)$

太完美了！這個結構告訴我們該怎麼做：
1.  先用一個 NOT 閘把 `a` 變成 `NOT a`。
2.  再用一個 NOT 閘把 `b` 變成 `NOT b`。
3.  最後把這兩個結果，一起送進一個 NAND 閘。

總共需要三個 NAND 閘。

**電路圖：**


**Verilog 實作：**
我們來組合 `my_or_gate` 吧！

```verilog
// ==========================================================
// 第三個作品：用 NAND 積木打造 OR 閘
// 功能: z = a OR b
// ==========================================================
module my_or_gate (
    input  wire a,
    input  wire b,
    output wire z
);

    // 這次需要兩條內部電線
    wire not_a_wire;
    wire not_b_wire;

    // 第一個積木 (NOT a):
    my_not_gate U1 (
        .in(a),
        .out(not_a_wire)
    );

    // 第二個積木 (NOT b):
    my_not_gate U2 (
        .in(b),
        .out(not_b_wire)
    );

    // 第三個積木 (最終的 NAND):
    nand_gate U3 (
        .a(not_a_wire),
        .b(not_b_wire),
        .z(z)
    );

endmodule
```

### 總結

同學，你剛剛完成了一個非常深刻的練習。我們從一個最原子的 `nand_gate` 出發，像玩樂高一樣，透過**組合**與**分層設計**，成功地搭建出了三種完全不同的邏輯功能：`NOT`、`AND` 和 `OR`。

這就是整個數位晶片設計的核心思想：

1.  **階層化 (Hierarchy)**：先設計小零件 (`my_not_gate`)，再用小零件去組合出更複雜的零件 (`my_and_gate`, `my_or_gate`)。
2.  **模組化 (Modularity)**：每個零件都是一個獨立的黑盒子，我們使用它的時候，只需要知道它的接口（輸入/輸出）和功能，不需要關心它內部是如何實現的。

接下來，我們就可以拿著我們自己打造的 `my_and_gate`、`my_or_gate` 當作新的積木，去組合出更強大的電路，例如「加法器」。這趟旅程是不是越來越有趣了呢？

## Q: 請寫 test bench 對上述元件進行測試

Excellent question! This is where the engineering discipline truly shines.

設計出一個電路，就像是寫出了一個演算法，這只是第一步。但你怎麼**證明**你設計的電路是正確的呢？你總不能等到花了大錢做出晶片後，才發現你的 AND 閘其實是個 OR 閘吧？

這就是 **Test Bench** (測試平台) 的用途。

---

### 什麼是 Test Bench？

你可以把 Test Bench 想像成一個**虛擬的實驗室工作台**。

*   你設計好的電路（`my_not_gate`, `my_and_gate` 等）就是**待測物 (Device Under Test, DUT)**。
*   Test Bench 就是你搭建的整個測試環境，包含：
    1.  **信號產生器**：用來產生各種輸入信號 (00, 01, 10, 11) 送給你的 DUT。
    2.  **探測棒/示波器**：用來觀察 DUT 的輸出信號，看看是否跟預期的一樣。
    3.  **腳本**：自動化整個測試流程，並印出報告。

最重要的一點：**Test Bench 本身是不可合成的 (Not Synthesizable)**。它只存在於模擬軟體中，用來**驗證**電路行為，它自己並不會被變成真正的硬體電路。

---

### Test Bench 的關鍵語法元素

在我們開始寫之前，先認識幾個 Test Bench 裡特有的東西：

*   `reg` (暫存器)：在 Test Bench 中，用來**驅動** DUT 輸入的信號必須宣告成 `reg`。你可以把它想像成信號產生器的**開關**，你可以主動控制它要輸出 0 還是 1。
*   `wire` (電線)：用來**接收** DUT 輸出的信號必須宣告成 `wire`。它就像示波器的探測棒，被動地**觀察**電路上的信號值。
*   `initial begin ... end`：這是一個**程序區塊 (Procedural Block)**，裡面的程式碼會從 `begin` 開始，**依序執行**到 `end` 就結束。我們的測試腳本就寫在這裡面。
*   `#` (延遲)：`#10` 的意思是在模擬世界中「**等待 10 個時間單位**」。這讓我們可以在不同時間點改變輸入信號，模擬真實的時序。
*   `$display`, `$monitor`：這是 Verilog 內建的「印出」功能，就像 C 語言的 `printf`，用來在模擬器的 console 顯示訊息。
*   `$finish`：結束整個模擬。

---

### 實作：一個測試所有閘的 Test Bench

我們不需要為每個閘寫一個 Test Bench，我們可以很有效率地在**同一個** Test Bench 裡，一次測試我們剛剛做好的所有電路。

**檔名： `tb_our_gates.v`**

```verilog
// ==========================================================
// Test Bench for our custom-built gates
// 這個檔案本身不會變成硬體，它只是一個測試用的腳本
// ==========================================================

// `timescale` 定義了模擬的時間單位和精度
// #1 代表延遲 1ns
`timescale 1ns / 1ps

// Test Bench 模組通常沒有 input/output
module tb_our_gates;

    // 1. 信號產生器 (用 reg)
    // 這些是我們要送給待測物的輸入信號
    reg tb_a;
    reg tb_b;

    // 2. 探測棒 (用 wire)
    // 這些是用來接收待測物輸出的信號
    wire not_out;
    wire and_out;
    wire or_out;

    // 3. 把待測物 (DUT) 放到我們的實驗台上
    // 實例化 my_not_gate，並連接電路
    my_not_gate dut_not (
        .in(tb_a),       // NOT 閘的輸入，由我們的 tb_a 開關控制
        .out(not_out)    // NOT 閘的輸出，連接到我們的 not_out 探測棒
    );

    // 實例化 my_and_gate，並連接電路
    my_and_gate dut_and (
        .a(tb_a),        // AND 閘的 a 輸入，由 tb_a 控制
        .b(tb_b),        // AND 閘的 b 輸入，由 tb_b 控制
        .z(and_out)      // AND 閘的輸出，連接到 an_out 探測棒
    );

    // 實例化 my_or_gate，並連接電路
    my_or_gate dut_or (
        .a(tb_a),        // OR 閘的 a 輸入，由 tb_a 控制
        .b(tb_b),        // OR 閘的 b 輸入，由 tb_b 控制
        .z(or_out)       // OR 閘的輸出，連接到 or_out 探測棒
    );


    // 4. 撰寫測試腳本
    initial begin
        // 使用 $monitor 來持續監控信號變化
        // 只要列表中的任何一個信號有變化，就會印出這一行
        $monitor("Time=%0t | Inputs: a=%b, b=%b | Outputs: NOT(a)=%b, AND=%b, OR=%b",
                 $time, tb_a, tb_b, not_out, and_out, or_out);

        // -- 開始我們的測試序列 --
        // 在模擬時間 0 時
        $display("--- Starting Test Sequence ---");
        tb_a = 0; tb_b = 0;

        // 等待 10 個時間單位 (10ns)
        #10;
        tb_a = 0; tb_b = 1;

        // 再等待 10ns
        #10;
        tb_a = 1; tb_b = 0;

        // 再等待 10ns
        #10;
        tb_a = 1; tb_b = 1;

        // 再等待 10ns，然後結束模擬
        #10;
        $display("--- Test Sequence Finished ---");
        $finish; // 結束模擬
    end

endmodule
```

### 如何執行與預期結果

你需要一個 Verilog 模擬器 (例如開源的 Icarus Verilog 或商業軟體 ModelSim/VCS) 來執行這個 Test Bench 檔案。當你執行它時，模擬器會載入你的設計檔案 (`my_not_gate`, `my_and_gate`...) 和這個測試檔案 (`tb_our_gates.v`)。

然後，模擬器會像一個導演，按照你 `initial begin...end` 裡的劇本，一步步推進模擬時間，並把 `$monitor` 指定的訊息印在 console 上。

**預期的 Console 輸出會是這樣：**

```
--- Starting Test Sequence ---
Time=0 | Inputs: a=0, b=0 | Outputs: NOT(a)=1, AND=0, OR=0
Time=10 | Inputs: a=0, b=1 | Outputs: NOT(a)=1, AND=0, OR=1
Time=20 | Inputs: a=1, b=0 | Outputs: NOT(a)=0, AND=0, OR=1
Time=30 | Inputs: a=1, b=1 | Outputs: NOT(a)=0, AND=1, OR=1
--- Test Sequence Finished ---
```

**結果分析：**

*   **Time=0, a=0, b=0**: `NOT(0)` 是 1，`0 AND 0` 是 0，`0 OR 0` 是 0。**正確！**
*   **Time=10, a=0, b=1**: `NOT(0)` 是 1，`0 AND 1` 是 0，`0 OR 1` 是 1。**正確！**
*   **Time=20, a=1, b=0**: `NOT(1)` 是 0，`1 AND 0` 是 0，`1 OR 0` 是 1。**正確！**
*   **Time=30, a=1, b=1**: `NOT(1)` 是 0，`1 AND 1` 是 1，`1 OR 1` 是 1。**正確！**

所有輸出都符合我們的預期！這代表我們用 NAND 閘打造出來的 NOT, AND, OR 電路，功能完全正確。我們成功地**驗證**了自己的設計。

這就是數位邏輯設計中「**設計**」與「**驗證**」的完整循環。在業界，驗證工程師的工作量甚至常常超過設計工程師，因為要確保在各種想得到、想不到的邊界條件下，晶片的行為都必須是 100% 正確的。

## Q: 什麼是多工器 (MUX) 與解多工器 (DMUX) ？

當然！多工器 (Multiplexer, MUX) 和解多工器 (Demultiplexer, DMUX) 是數位電路中極其重要的「交通管制」元件。

如果說邏輯閘是蓋房子的「磚塊」，那麼 MUX 和 DMUX 就是房子裡的「**通道和門**」，它們控制著資訊（資料）的流向。

---

### 多工器 (Multiplexer, MUX)：多選一的「選擇器」

**核心功能**：從多個輸入信號中，**選擇一個**，然後把它傳送到唯一的輸出通道上。

**生活中的比喻：電視的訊號源切換**
想像你的電視後面接了好幾個裝置：
*   輸入 0: PlayStation 5
*   輸入 1: 電視機上盒
*   輸入 2: Apple TV

你的電視螢幕只有**一個** (唯一的輸出)。你手上的**遙控器**就是「選擇信號 (Select Signal)」。

*   當你按下遙控器，選擇「HDMI 1」(Select = 0)，PlayStation 的畫面就會出現在螢幕上。
*   當你按下遙控器，選擇「HDMI 2」(Select = 1)，機上盒的畫面就會出現在螢幕上。

MUX 就是數位電路裡的那個**自動化遙控器**。

#### 一個 2-to-1 MUX 的細節

這是最簡單的 MUX，它有 2 個資料輸入、1 個選擇輸入、1 個資料輸出。

*   **資料輸入 (Data Inputs)**: `i0`, `i1`
*   **選擇輸入 (Select Input)**: `s`
*   **資料輸出 (Data Output)**: `y`

**運作規則：**
*   **如果** `s` 的信號是 `0`，**那麼** 輸出 `y` 的值就等於輸入 `i0` 的值。
*   **如果** `s` 的信號是 `1`，**那麼** 輸出 `y` 的值就等於輸入 `i1` 的值。

**真值表 (Truth Table):**

|   s   | `i1`  | `i0`  |   y   | 說明 |
| :---: | :---: | :---: | :---: | :--- |
|   0   |   X   |   0   |   0   | s=0, 選擇 i0 |
|   0   |   X   |   1   |   1   | s=0, 選擇 i0 |
|   1   |   0   |   X   |   0   | s=1, 選擇 i1 |
|   1   |   1   |   X   |   1   | s=1, 選擇 i1 |
(X 代表 "Don't Care"，表示此時這個輸入的值不影響結果)

**Verilog 實作 (2-to-1 MUX):**
我們可以用 Verilog 的「三元運算子 `?:`」來非常優雅地描述這個選擇行為。

```verilog
// ==========================================================
// 模組: 一個 2-to-1 的多工器 (MUX)
// ==========================================================
module mux_2_to_1 (
    input  wire i0, // 輸入選項 0
    input  wire i1, // 輸入選項 1
    input  wire s,  // 選擇信號
    output wire y   // 唯一的輸出
);

    // 描述行為：如果 s 為真(1)，則 y 等於 i1，否則 y 等於 i0。
    assign y = s ? i1 : i0;

endmodule
```
這個簡單的元件在 CPU 裡無所不在。例如，ALU 的運算結果，到底是要從暫存器來的資料，還是從指令中直接給的常數？這就需要一個 MUX 來做選擇。

---

### 解多工器 (Demultiplexer, DMUX)：一分多的「分配器」

**核心功能**：將一個輸入信號，根據選擇信號，**分配到**多個輸出通道中的**其中一個**。

**生活中的比喻：火車調度中心的道岔**
想像一列火車（唯一的輸入信號）要駛入一個有很多月台的車站。
*   **火車** (唯一的資料輸入)
*   **月台 1, 月台 2, 月台 3...** (多個資料輸出)
*   **調度員的控制桿** (選擇信號)

調度員根據這列火車的目的地，扳動控制桿（選擇信號），道岔就會改變，讓火車準確地駛入指定的月台。其他所有月台都沒有火車駛入。

DMUX 就是數位電路裡的那個**自動化道岔**。

#### 一個 1-to-2 DMUX 的細節

這是最簡單的 DMUX，它有 1 個資料輸入、1 個選擇輸入、2 個資料輸出。

*   **資料輸入 (Data Input)**: `d`
*   **選擇輸入 (Select Input)**: `s`
*   **資料輸出 (Data Outputs)**: `o0`, `o1`

**運作規則：**
*   **如果** `s` 的信號是 `0`，**那麼** 輸出 `o0` 的值就等於輸入 `d` 的值，同時 `o1` 的值為 `0`。
*   **如果** `s` 的信號是 `1`，**那麼** 輸出 `o1` 的值就等於輸入 `d` 的值，同時 `o0` 的值為 `0`。

**真值表 (Truth Table):**

|   s   |   d   |  `o1` |  `o0` | 說明 |
| :---: | :---: | :---: | :---: | :--- |
|   0   |   0   |   0   |   0   | s=0, d 被送到 o0 |
|   0   |   1   |   0   |   1   | s=0, d 被送到 o0 |
|   1   |   0   |   0   |   0   | s=1, d 被送到 o1 |
|   1   |   1   |   1   |   0   | s=1, d 被送到 o1 |

**Verilog 實作 (1-to-2 DMUX):**
我們可以用 AND 閘的特性來實作。一個信號和 1 做 AND 運算，結果是信號本身；和 0 做 AND 運算，結果永遠是 0。

```verilog
// ==========================================================
// 模組: 一個 1-to-2 的解多工器 (DMUX)
// ==========================================================
module dmux_1_to_2 (
    input  wire d,  // 唯一的資料輸入
    input  wire s,  // 選擇信號
    output wire o0, // 輸出通道 0
    output wire o1  // 輸出通道 1
);

    // 描述行為：
    // 如果 s=0 (則 ~s=1), o0 = 1 & d = d; o1 = 0 & d = 0
    assign o0 = (~s) & d;
    
    // 如果 s=1, o0 = 0 & d = 0; o1 = 1 & d = d
    assign o1 = s & d;

endmodule
```

DMUX 在 CPU 裡也至關重要。例如，當計算結果出來後，要把它存回 32 個暫存器中的**哪一個**？這時就需要一個 DMUX（或更複雜的解碼器）來「打開」通往目標暫存器的「門」，把資料寫進去。

### 總結

| | **多工器 (MUX)** | **解多工器 (DMUX)** |
| :--- | :--- | :--- |
| **別名** | 選擇器 (Selector) | 分配器 (Distributor) |
| **功能** | 多個輸入，一個輸出 | 一個輸入，多個輸出 |
| **資料流** | Many -> 1 | 1 -> Many |
| **比喻** | 電視訊號源切換 | 火車道岔 |
| **在CPU中的作用** | **選擇**資料來源 (例如：暫存器 vs 常數) | **指定**資料目的地 (例如：寫入哪個暫存器) |

MUX 和 DMUX 是構成 CPU **資料路徑 (Datapath)** 的關鍵元件，它們共同確保了資料能在正確的時間，從正確的來源，流向正確的目的地。它們是電腦硬體世界裡不可或缺的交通警察。

## Q: 多工器和 IF 語句的功能差不多嗎？

你這個問題問得太好了！可以說，你已經觸及到了軟體與硬體之間最核心的橋樑之一。

答案是：**在「功能行為」上，它們非常相似；但在「底層實現」和「思維模型」上，它們有著根本的不同。**

讓我們深入地剖析這個問題。

---

### 相同之處：它們都在做「選擇」

從一個抽象的、行為層級的角度來看，一個 2-to-1 MUX 和一個 `if-else` 語句都在完成同樣的任務：**根據一個條件，從兩個選項中選擇一個結果**。

你看，它們的描述幾乎可以互換：

**軟體世界 (C / Python)**

```c
// 如果 (s 等於 1)
if (s == 1) {
    // 那麼 y 就等於 i1
    y = i1;
}
// 否則
else {
    // y 就等於 i0
    y = i0;
}
```

這個 C 語言的 `if-else` 結構，和我們 Verilog 裡 MUX 的三元運算子 `?:` 描述的行為，是不是看起來一模一樣？

**硬體世界 (Verilog)**

```verilog
// 將 y 的值持續地指派為：如果 s 為 1，則選擇 i1，否則選擇 i0
assign y = s ? i1 : i0;
```

所以你的直覺完全正確，它們在邏輯功能上是等價的。

---

### 根本不同之處：指令 vs. 結構

現在，讓我們揭開表面，看看冰山底下發生了什麼。

#### 1. 實現方式：循序的「指令」 vs. 並行的「電路」

*   **IF 語句 (軟體指令)**
    *   這是一條給 CPU 的**指令**。當 CPU 執行到這段程式碼時，它會做一系列**循序的動作**：
        1.  **檢查** `s` 的值。
        2.  根據結果，進行一次「**跳躍 (Jump/Branch)**」。這就像走到一個岔路口，CPU 必須決定要走左邊的路（`if` 區塊）還是右邊的路（`else` 區塊）。
        3.  執行被選中那條路上的指令（例如 `y = i1`）。
        4.  **跳過**另一條路上的指令。
    *   關鍵詞：**時間上是循序的 (Sequential in Time)**。CPU 不會同時執行 `if` 和 `else` 的部分。

*   **多工器 MUX (硬體結構)**
    *   這不是指令，而是一個**實體的電路結構**。它是由一堆 AND, OR, NOT 閘組成的物理實體。
    *   輸入 `i0` 和 `i1` 的信號是**同時**流到這個 MUX 電路裡的。
    *   選擇信號 `s` 就像一個水管的閥門。它不是告訴 CPU 要「跳到」哪裡，而是**物理上**打開一條通路，關閉另一條通路。
    *   **兩條資料路徑都一直存在**，只是在任何一個時間點，只有一條路徑的信號能通過。
    *   關鍵詞：**空間上是並行的 (Parallel in Space)**。整個選擇的過程幾乎是瞬時發生的（只受電信號傳播延遲的影響）。

#### 2. 效能影響：分支預測懲罰 (Branch Penalty)

*   **IF 語句 (可能很慢)**
    *   在現代 CPU 中，為了速度，指令都是像工廠流水線一樣執行的（這就是我們提過的**管線化 Pipelining**）。CPU 會**預測** `if` 語句最可能走哪條路，然後提前把那條路上的指令抓進來準備執行。
    *   如果 CPU **猜錯了**（例如，它以為 `s` 會是 1，結果 `s` 是 0），它就必須丟掉所有已經做好的準備工作，回頭去抓另一條路上的指令，這會造成幾個時脈週期的延遲。這就是所謂的「**分支預測錯誤懲罰 (Branch Misprediction Penalty)**」。這在效能要求極高的程式中，是一個很大的問題。

*   **多工器 MUX (速度恆定)**
    *   MUX 是一個純粹的**組合邏輯電路**。它的延遲只跟邏輯閘的物理延遲有關，這個延遲是固定的、可預測的。
    *   它沒有「猜測」的過程，也就沒有「懲罰」。給定輸入，輸出結果就是確定的。

### 軟體與硬體的交會點：編譯器 (Compiler)

現在最有趣的問題來了：當你寫下 `y = s ? i1 : i0;` 這樣的 C 程式碼時，編譯器會把它變成什麼樣的機器碼？

1.  **傳統方式**：編譯器可能會把它翻譯成帶有「條件跳躍」的指令，也就是我們上面說的 `if-else` 的實現方式。

2.  **最佳化方式**：一個聰明的編譯器，會辨認出這是一個簡單的選擇。它可能會使用一條叫做 `CMOV` (Conditional Move，條件移動) 的特殊指令。這條指令在硬體層級的行為就**非常像一個 MUX**！它告訴 CPU：「你把兩個結果都準備好，然後根據條件旗標，直接把正確的結果寫入目標暫存器，**不要跳躍**。」這樣就避免了分支預測失敗的風險。

---

### 總結

| 特性 (Characteristic) | IF 語句 (軟體) | 多工器 (硬體) |
| :--- | :--- | :--- |
| **基本概念** | 一個**循序執行的指令** | 一個**並行運作的結構** |
| **實現方式** | CPU 檢查條件，然後**跳躍**到不同程式碼區塊 | 物理電路根據選擇信號**打開/關閉**資料通路 |
| **思維模型** | 時間上的循序 (Sequential) | 空間上的並行 (Concurrent) |
| **效能影響** | 可能有分支預測懲罰，導致延遲不固定 | 延遲固定且可預測 |
| **對應關係** | 一個 `if-else` **可能會被**編譯器最佳化成 MUX-like 的硬體指令 | 一個 MUX **實現了** `if-else` 的選擇功能 |

所以，身為一個資工系的學生，理解 MUX 至關重要。它不僅僅是一個硬體元件，它代表了一種**硬體思維模式**——用並行的結構來解決問題，而不是用循序的指令。當你未來在寫程式追求極致效能時，腦中想著「如何讓我的程式碼更像 MUX，而不是 IF」，你就會寫出讓編譯器更容易最佳化、效能更好的程式碼。

## Q: 請用 and, or, not 做出一個多工器

絕對可以！這是一個非常經典的練習，它能讓你徹底看透 MUX 的本質，明白它並不是什麼魔法，而只是由我們最熟悉的基本邏輯閘巧妙組合而成的。

我們就來打造一個 2-to-1 MUX。

---

### 第 1 步：重新思考 MUX 的邏輯

首先，我們拋開 `s ? i1 : i0` 這種高階的描述，回到最原始的邏輯判斷。一個 2-to-1 MUX 的規則是：

1.  **當** 選擇信號 `s` 是 `0` **而且** `i0` 通道有信號時，輸出 `y` 應該等於 `i0`。
2.  **當** 選擇信號 `s` 是 `1` **而且** `i1` 通道有信號時，輸出 `y` 應該等於 `i1`。

最終的輸出 `y` 應該是這兩種情況的**其中一種**。

### 第 2 步：將邏輯翻譯成布林代數

現在，我們把上面的中文描述，一步步翻譯成由 AND, OR, NOT 組成的數學式。

*   "當選擇信號 `s` 是 `0`" -> 這個條件可以用 `NOT s` 來表示。當 `s=0` 時，`NOT s` 就是 `1` (代表條件成立)。
*   所以，第一條規則 "(`s` 是 `0`) AND (`i0` 的值)" 可以寫成：
    $term_0 = (NOT \ s) \ \& \ i_0$

    *   讓我們來驗證一下：
        *   如果 `s=0`，`NOT s` 是 `1`，所以 $term_0 = 1 \ \& \ i_0 = i_0$。成功把 `i0` 的值傳遞過來了！
        *   如果 `s=1`，`NOT s` 是 `0`，所以 $term_0 = 0 \ \& \ i_0 = 0$。成功把 `i0` 的通道給「關閉」了！

*   "當選擇信號 `s` 是 `1`" -> 這個條件可以直接用 `s` 來表示。
*   所以，第二條規則 "(`s` 是 `1`) AND (`i1` 的值)" 可以寫成：
    $term_1 = s \ \& \ i_1$

    *   讓我們也來驗證一下：
        *   如果 `s=1`，`s` 是 `1`，所以 $term_1 = 1 \ \& \ i_1 = i_1$。成功把 `i1` 的值傳遞過來了！
        *   如果 `s=0`，`s` 是 `0`，所以 $term_1 = 0 \ \& \ i_1 = 0$。成功把 `i1` 的通道給「關閉」了！

*   最後，輸出 `y` 是這兩種情況的**其中一種** (`OR`)。所以我們把兩個結果 `OR` 在一起：
    $y = term_0 \ | \ term_1$
    $y = ((NOT \ s) \ \& \ i_0) \ | \ (s \ \& \ i_1)$

這就是我們 MUX 的**設計藍圖**！這個公式告訴我們，需要 1 個 NOT 閘、2 個 AND 閘和 1 個 OR 閘。

### 第 3 步：畫出電路圖

根據上面的公式，我們可以非常直觀地畫出電路圖：



### 第 4 步：用 Verilog 實現電路圖

現在，我們就把上面畫的電路圖，用「結構化 (Structural)」的 Verilog 語法描述出來。這就像是在用文字拼裝樂高積木。

```verilog
// ==========================================================
// 模組: 一個由基礎邏輯閘搭建的 2-to-1 MUX
// 實現公式: y = ((~s) & i0) | (s & i1)
// ==========================================================
module mux_2_to_1_from_gates (
    input  wire i0, // 輸入選項 0
    input  wire i1, // 輸入選項 1
    input  wire s,  // 選擇信號
    output wire y   // 唯一的輸出
);

    // 宣告連接各個閘的內部電線
    wire not_s_wire;
    wire term0_wire;
    wire term1_wire;

    // ----- 電路實作 -----

    // 1. 一個 NOT 閘，用來反轉 s
    // 我們假設已經有 not_gate, and_gate, or_gate 這些模組
    // 當然也可以直接用 Verilog 的 ~, &, |
    not_gate U_NOT (
        .in(s),
        .out(not_s_wire)
    );
    
    // 2. 兩個 AND 閘，分別建立兩個資料通道
    // 通道 0: 只有在 s=0 (~s=1) 時才會開啟
    and_gate U_AND0 (
        .a(not_s_wire),
        .b(i0),
        .z(term0_wire)
    );

    // 通道 1: 只有在 s=1 時才會開啟
    and_gate U_AND1 (
        .a(s),
        .b(i1),
        .z(term1_wire)
    );

    // 3. 一個 OR 閘，將兩個通道的結果匯合到輸出
    // 在任何時間點，term0 和 term1 中一定有一個是 0
    or_gate U_OR (
        .a(term0_wire),
        .b(term1_wire),
        .z(y)
    );

endmodule
```

#### 更簡潔的「資料流」寫法

當然，Verilog 也允許我們直接把布林代數公式寫出來，這種風格叫做「資料流建模 (Dataflow Modeling)」。它和上面的結構化寫法在功能上是**完全等價的**。對於合成器來說，它看到的都是一樣的邏輯。

```verilog
// ==========================================================
// 模組: 用資料流模型描述的 2-to-1 MUX
// ==========================================================
module mux_2_to_1_dataflow (
    input  wire i0,
    input  wire i1,
    input  wire s,
    output wire y
);

    // 直接將我們的設計藍圖公式寫出來
    assign y = (~s & i0) | (s & i1);

endmodule
```

### 總結

今天你又完成了一次非常重要的跨越！

我們從一個高階的行為描述 (`if-else` 或 `?:`)，深入到底層的布林代數公式 ($y = ((NOT \ s) \ \& \ i_0) \ | \ (s \ \& \ i_1)$)，最後親手用最基本的邏輯閘將它實現為一個**實體的電路結構**。

這完美地展示了抽象層次之間的轉換：
`高階行為` -> `布林邏輯` -> `閘級結構`

理解了這個過程，你就真正掌握了數位電路設計的精髓。任何複雜的組合邏輯電路，無論是加法器、比較器還是 CPU 的解碼單元，其最底層的原理都和我們今天做的這個練習是完全一樣的。

## Q: 請用 and, or, not 做一個解多工器 DMUX

好的，這個練習將會和 MUX 的練習形成一個完美的對稱，讓你更深刻地理解 MUX 和 DMUX 之間鏡像般的關係。

我們要來打造一個 1-to-2 的解多工器 (DMUX)。

---

### 第 1 步：重新思考 DMUX 的邏輯

一個 1-to-2 DMUX 的核心功能是「分配」。它有一個資料輸入 `d`，一個選擇信號 `s`，和兩個輸出 `o0`、`o1`。規則如下：

1.  **如果** 選擇信號 `s` 是 `0`，那麼 `o0` 應該得到 `d` 的值，同時 `o1` 必須是 `0` (關閉)。
2.  **如果** 選擇信號 `s` 是 `1`，那麼 `o1` 應該得到 `d` 的值，同時 `o0` 必須是 `0` (關閉)。

### 第 2 步：將邏輯翻譯成布林代數

現在我們來為**每一個輸出**分別寫下它們的邏輯公式。這裡的關鍵是使用 **AND** 閘來扮演「**守門員 (Gatekeeper)**」的角色。只有當「選擇條件」和「資料信號」同時為真時，門才會打開。

#### 針對輸出 `o0`：

*   它被選中的條件是 "`s` 是 `0`"，也就是 `NOT s`。
*   當它被選中時，它的值應該是 `d`。
*   所以，`o0` 的邏輯是：**(`s` 是 `0`) AND (`d` 的值)**。
*   公式為：$o_0 = (NOT \ s) \ \& \ d$

    *   來驗證一下：
        *   當 `s=0`，公式變成 $o_0 = (NOT \ 0) \ \& \ d = 1 \ \& \ d = d$。**正確！**
        *   當 `s=1`，公式變成 $o_0 = (NOT \ 1) \ \& \ d = 0 \ \& \ d = 0$。**正確！**

#### 針對輸出 `o1`：

*   它被選中的條件是 "`s` 是 `1`"，也就是 `s`。
*   當它被選中時，它的值應該是 `d`。
*   所以，`o1` 的邏輯是：**(`s` 是 `1`) AND (`d` 的值)**。
*   公式為：$o_1 = s \ \& \ d$

    *   來驗證一下：
        *   當 `s=0`，公式變成 $o_1 = 0 \ \& \ d = 0$。**正確！**
        *   當 `s=1`，公式變成 $o_1 = 1 \ \& \ d = d$。**正確！**

我們現在得到了 DMUX 的設計藍圖，它需要 1 個 NOT 閘和 2 個 AND 閘。注意到了嗎？和 MUX 不同，它**不需要 OR 閘**，因為它的輸出是分開的，不需要匯合。

### 第 3 步：畫出電路圖

根據上面兩個獨立的公式，我們可以畫出電路圖：



### 第 4 步：用 Verilog 實現電路圖

我們再次使用「結構化」的 Verilog 語法，把電路圖如實地描述出來。

```verilog
// ==========================================================
// 模組: 一個由基礎邏輯閘搭建的 1-to-2 DMUX
// 實現公式: o0 = (~s) & d;  o1 = s & d;
// ==========================================================
module dmux_1_to_2_from_gates (
    input  wire d,  // 唯一的資料輸入
    input  wire s,  // 選擇信號
    output wire o0, // 輸出通道 0
    output wire o1  // 輸出通道 1
);

    // 宣告內部電線，用來連接 NOT 閘的輸出
    wire not_s_wire;

    // ----- 電路實作 -----

    // 1. 一個 NOT 閘，用來產生 "s=0" 這個條件
    not_gate U_NOT (
        .in(s),
        .out(not_s_wire)
    );

    // 2. 兩個 AND 閘，分別控制兩個輸出通道
    // 通道 0 的守門員: 只有在 s=0 (~s=1) 時才會打開
    and_gate U_AND0 (
        .a(not_s_wire),
        .b(d),
        .z(o0)
    );

    // 通道 1 的守門員: 只有在 s=1 時才會打開
    and_gate U_AND1 (
        .a(s),
        .b(d),
        .z(o1)
    );

endmodule
```

#### 更簡潔的「資料流」寫法

同樣地，我們可以把布林公式直接寫成 Verilog 的 `assign` 敘述，這在功能上是完全等價的。

```verilog
// ==========================================================
// 模組: 用資料流模型描述的 1-to-2 DMUX
// ==========================================================
module dmux_1_to_2_dataflow (
    input  wire d,
    input  wire s,
    output wire o0,
    output wire o1
);

    // 直接將我們的設計藍圖公式寫出來
    assign o0 = (~s) & d;
    assign o1 = s & d;

endmodule
```

### MUX 與 DMUX 的對稱之美

現在，請你比較一下我們用邏輯閘打造的 MUX 和 DMUX 的結構：

*   **MUX (多選一)**：
    1.  用 AND 閘為每個輸入通道建立「開關」。
    2.  用 OR 閘將所有通道的結果**匯合**到一個輸出。
    3.  結構：`ANDs -> OR`

*   **DMUX (一分多)**：
    1.  輸入信號 `d` **分流**到每一個輸出通道。
    2.  用 AND 閘為每一個輸出通道建立「開關」。
    3.  結構：`ANDs` (輸出是分離的)

它們都巧妙地利用了 **AND 閘作為條件開關** 的特性，但 MUX 多了一步「匯合 (OR)」，而 DMUX 則是純粹的「分發 (ANDs)」。

理解了這兩個元件的底層邏輯，你就掌握了數位電路中控制資料流動方向的基礎。接下來，無論是多麼複雜的資料路徑，其本質都是由這些基礎的「選擇」與「分配」邏輯所構成的。

## Q: 如果輸入不是單一條，而是 16 條，那麼如何做出 MUX16

這個問題非常好，直接切入了數位邏輯設計從「理論」走向「實務」的關鍵一步！在真實的電腦裡，資料幾乎都不是單獨一條線 (1-bit) 在跑，而是像一支軍隊一樣，8條、16條、32條、64條線並排前進。

這種**一組並排的電線**，我們稱之為「**匯流排 (Bus)**」。

所以，你的問題「輸入不是單一條，而是 16 條」，意思就是我們要處理的資料是一個 16-bit 的匯流排。

---

### 概念升級：從單線道到 16 線道高速公路

*   **1-bit MUX**：就像一個只有單線道的交流道。選擇信號 `s` 決定要讓來自 `i0` **那輛車**上主幹道，還是讓來自 `i1` **那輛車**上主幹道。

*   **16-bit MUX**：現在，我們的輸入是兩條**各自擁有 16 線道的超級高速公路** (`i0` 和 `i1`)。我們的 MUX 就像一個巨大的交流道系統。選擇信號 `s` 不再是只指揮一輛車，而是一聲令下，**同時**指揮 `i0` 公路上的**所有 16 輛車**開上主幹道 `y`，或者**同時**指揮 `i1` 公路上的**所有 16 輛車**開上主幹道 `y`。

這個「同時」是關鍵。硬體的並行特性在這裡體現得淋漓盡致。

---

### 如何用 Verilog 描述 16-bit Bus？

我們使用 `[MSB:LSB]` 語法來定義一個匯流排的寬度。`MSB` 是最高有效位 (Most Significant Bit)，`LSB` 是最低有效位 (Least Significant Bit)。對於一個 16-bit 的匯流排，我們通常定義為 `[15:0]`，代表它包含了第 0, 1, 2, ..., 15 條線。

### 實作一：2-to-1 MUX for 16-bit Data

這是對你問題最直接的詮釋：一個 2 選 1 的多工器，但它的每一個輸入和輸出都是 16-bit 寬。

**Verilog 程式碼：**
神奇的是，程式碼看起來和 1-bit 版本幾乎一模一樣！這就是硬體描述語言抽象化的威力。

```verilog
// ==========================================================
// 模組: 一個 2-to-1 MUX，處理 16-bit 寬的匯流排
// ==========================================================
module mux_2_to_1_16bit (
    input  wire [15:0] i0, // 輸入選項 0，是一個 16-bit 的 bus
    input  wire [15:0] i1, // 輸入選項 1，也是一個 16-bit 的 bus
    input  wire        s,  // 選擇信號，仍然是 1-bit
    output wire [15:0] y   // 唯一的輸出，也是一個 16-bit 的 bus
);

    // 描述行為：完全一樣的語法！
    // Verilog 會自動理解這是在對整個 bus 進行操作
    assign y = s ? i1 : i0;

endmodule
```

**這段程式碼背後發生了什麼？**

當合成器讀到 `assign y = s ? i1 : i0;` 這一行，並且發現 `i0`, `i1`, `y` 都是 16-bit 寬時，它不會只產生一個 MUX。它會自動**實例化 16 個**我們之前做的 1-bit 2-to-1 MUX，像這樣：

*   `y[0]` 由 `i0[0]` 和 `i1[0]` 選擇而出。
*   `y[1]` 由 `i0[1]` 和 `i1[1]` 選擇而出。
*   ...
*   `y[15]` 由 `i0[15]` 和 `i1[15]` 選擇而出。

最重要的是，這 **16 個 MUX 共用同一個選擇信號 `s`**。所以 `s` 就像一個總司令，同時對 16 個士兵下達同一個指令。



---

### 實作二：16-to-1 MUX for 1-bit Data (MUX16)

你的問題也可能是在問這個：如果我們有 16 個**不同的** 1-bit 輸入，要從中選出一個，該怎麼辦？這就是一個 16-to-1 MUX。

**思考：**
我們有 16 個選項（`i0` 到 `i15`）。要從 16 個選項中唯一地選出一個，我們需要多少個位元的選擇信號？

答案是 $log_2(16) = 4$。我們需要一個 4-bit 的選擇匯流排 `s[3:0]`。
*   當 `s` 是 `4'b0000` (十進位的 0)，我們選擇 `i0`。
*   當 `s` 是 `4'b0001` (十進位的 1)，我們選擇 `i1`。
*   ...
*   當 `s` 是 `4'b1111` (十進位的 15)，我們選擇 `i15`。

**Verilog 程式碼：**
對於這種多選項的選擇，使用 `case` 語句來描述是最清晰、最直觀的。

```verilog
// ==========================================================
// 模組: 一個 16-to-1 MUX，處理 1-bit 寬的資料
// ==========================================================
module mux_16_to_1 (
    // 我們有 16 個 1-bit 輸入
    input wire i0, i1, i2, i3, i4, i5, i6, i7, 
               i8, i9, i10, i11, i12, i13, i14, i15,
    
    input  wire [3:0] s,   // 4-bit 的選擇信號
    output reg        y    // 1-bit 的輸出
);

    // 當描述像 case 這樣的複雜組合邏輯時，我們常用 always 區塊
    // always @(*) 表示：只要括號裡任何一個輸入信號有變化，就重新執行一次這個區塊
    always @(*) begin
        case (s)
            4'b0000: y = i0;
            4'b0001: y = i1;
            4'b0010: y = i2;
            4'b0011: y = i3;
            4'b0100: y = i4;
            4'b0101: y = i5;
            4'b0110: y = i6;
            4'b0111: y = i7;
            4'b1000: y = i8;
            4'b1001: y = i9;
            4'b1010: y = i10;
            4'b1011: y = i11;
            4'b1100: y = i12;
            4'b1101: y = i13;
            4'b1110: y = i14;
            4'b1111: y = i15;
            default: y = 1'b0; // 預設值，避免產生閂鎖 (latch)
        endcase
    end

endmodule
```
**注意**：在 `always` 區塊內被賦值的信號（如 `y`），必須被宣告為 `reg` 型態。這是 Verilog 的一條語法規則。

### 終極合體：16-to-1 MUX for 16-bit Data

當然，我們也可以把上面兩種情況結合起來：一個 16 選 1 的 MUX，且每一個選項都是 16-bit 寬的匯流排。程式碼的改動非常直觀：

```verilog
module mux_16_to_1_16bit (
    input wire [15:0] i0, i1, ..., i15, // 假設宣告了 16 個 16-bit 輸入
    input wire [3:0] s,
    output reg [15:0] y
);
    always @(*) begin
        case(s)
            4'b0000: y = i0;
            4'b0001: y = i1;
            // ... 以此類推 ...
            4'b1111: y = i15;
            default: y = 16'b0;
        endcase
    end
endmodule
```

### 總結

| MUX 類型 | 資料輸入 | 選擇信號 | 資料輸出 | 核心概念 |
| :--- | :--- | :--- | :--- | :--- |
| **2-to-1 (1-bit)** | 2 個 1-bit | 1 個 1-bit | 1 個 1-bit | 基礎 MUX |
| **2-to-1 (16-bit)** | 2 個 16-bit bus | 1 個 1-bit | 1 個 16-bit bus | **資料匯流排 (Bus)** |
| **16-to-1 (1-bit)** | 16 個 1-bit | 1 個 4-bit bus | 1 個 1-bit | **選擇匯流排 (Select Bus)** |
| **16-to-1 (16-bit)** | 16 個 16-bit bus | 1 個 4-bit bus | 1 個 16-bit bus | 兩種匯流排概念的結合 |

你已經從處理單一信號，升級到了處理**匯流排**。這是數位邏輯設計中管理複雜性的最重要方法。CPU 內部所有資料的流動，都是在寬度為 32-bit 或 64-bit 的巨大匯流排上，由各種 MUX 進行著精確的交通管制。

## Q: 如果用 16 個 MUX 來組合，該怎麼做？

太棒了！這正是我希望你會問的問題。

直接寫 `assign y = s ? i1 : i0;` 這種寫法，我們稱為「**行為級建模 (Behavioral Modeling)**」。你描述的是電路**應該做什麼**。

而現在你問的，用 16 個 1-bit MUX 來組合，這叫做「**結構級建模 (Structural Modeling)**」。你描述的是電路**是由什麼零件組成的**，以及這些零件是**如何連接的**。

對於合成器來說，這兩種寫法的最終結果是完全一樣的。但從學習的角度，親手做一次結構級建模，能讓你對硬體的「並行」特性有更深刻的體會。

---

### 第 1 步：準備好我們的基本積木

我們的基本積木就是之前設計好的 1-bit 2-to-1 MUX。我們先把它放在旁邊，待會要用它。

```verilog
// 我們的基本積木：1-bit 2-to-1 MUX
module mux_2_to_1 (
    input  wire i0,
    input  wire i1,
    input  wire s,
    output wire y
);
    assign y = s ? i1 : i0;
endmodule
```

### 第 2 步：設計 16-bit MUX 的外殼

現在我們來設計 `mux_2_to_1_16bit_structural` 這個新模組。它的接口 (ports) 和我們之前做的行為級版本完全一樣。

```verilog
// ==========================================================
// 模組: 一個 "結構化" 的 2-to-1 MUX，處理 16-bit 匯流排
// 內部由 16 個 1-bit MUX 組成
// ==========================================================
module mux_2_to_1_16bit_structural (
    input  wire [15:0] i0,
    input  wire [15:0] i1,
    input  wire        s,
    output wire [15:0] y
);

    // 接下來，我們要在這裡面放入 16 個積木...

endmodule
```

### 第 3 步：把積木一個一個放進去 (手動方式)

這就像你在麵包板上插電路一樣，我們需要手動連接每一條線。

*   拿出第 1 個 `mux_2_to_1` 積木，把它叫做 `mux_bit0`。
*   把它的 `i0` 接腳，連到 `i0` 匯流排的第 `[0]` 條線。
*   把它的 `i1` 接腳，連到 `i1` 匯流排的第 `[0]` 條線。
*   把它的 `s` 接腳，連到**總選擇線** `s`。
*   把它的 `y` 輸出，連到 `y` 匯流排的第 `[0]` 條線。

然後對第 1, 2, 3, ... , 15 條線重複這個過程。

**Verilog 程式碼 (手動實例化):**

```verilog
module mux_2_to_1_16bit_structural (
    input  wire [15:0] i0,
    input  wire [15:0] i1,
    input  wire        s,
    output wire [15:0] y
);

    // 實例化 16 個 1-bit MUX
    
    // 處理 bit 0
    mux_2_to_1 mux_bit0 (
        .i0(i0[0]), 
        .i1(i1[0]), 
        .s(s),       // 注意：所有的 s 都連接到同一個信號源
        .y(y[0])
    );

    // 處理 bit 1
    mux_2_to_1 mux_bit1 (
        .i0(i0[1]), 
        .i1(i1[1]), 
        .s(s), 
        .y(y[1])
    );

    // 處理 bit 2
    mux_2_to_1 mux_bit2 (
        .i0(i0[2]), 
        .i1(i1[2]), 
        .s(s), 
        .y(y[2])
    );

    // ... 以此類推，直到 bit 15 ...

    // 處理 bit 15
    mux_2_to_1 mux_bit15 (
        .i0(i0[15]), 
        .i1(i1[15]), 
        .s(s), 
        .y(y[15])
    );

endmodule
```
這個方法非常直觀，但你可以看到，如果要設計一個 64-bit 的 MUX，手動寫 64 次會非常痛苦且容易出錯。

---

### 第 4 步：更聰明的方法 - `generate` for 迴圈

Verilog 提供了一個強大的工具，專門用來產生這種**重複性的硬體結構**，它就是 `generate` 迴圈。

這**不是**一個軟體迴圈。它是在「**編譯時期**」執行的迴圈。你可以把它想像成一個自動化的藍圖繪製機器，你告訴它規則，它會幫你把上面那 16 個 MUX 的實例化程式碼**自動生成**出來。

**Verilog 程式碼 (使用 generate):**

```verilog
// ==========================================================
// 模組: 使用 generate 迴圈來結構化的 2-to-1 MUX
// ==========================================================
module mux_2_to_1_16bit_structural_gen (
    input  wire [15:0] i0,
    input  wire [15:0] i1,
    input  wire        s,
    output wire [15:0] y
);

    // 宣告一個 generate 迴圈專用的整數變數
    genvar i;

    // generate 區塊開始
    generate
        // 這是一個 "for" 迴圈，它會在編譯時展開
        // 從 i=0 到 i=15，總共執行 16 次
        for (i = 0; i < 16; i = i + 1) begin : MUX_INSTANCES
            
            // 在迴圈的每一次，都實例化一個 1-bit MUX
            // 注意看索引 [i] 是如何被使用的
            mux_2_to_1 mux_inst (
                .i0(i0[i]), 
                .i1(i1[i]), 
                .s(s),      // s 仍然是共用的
                .y(y[i])
            );
            
        end
    endgenerate

endmodule
```

**`generate` 迴圈做了什麼？**

當合成器看到這段程式碼時，它會做這樣的事情：
1.  `i=0` 時，生成 `mux_bit0` 的程式碼。
2.  `i=1` 時，生成 `mux_bit1` 的程式碼。
3.  ...
4.  `i=15` 時，生成 `mux_bit15` 的程式碼。

最終，它在記憶體中產生的電路網表 (netlist) 和我們手動寫 16 次的版本是**一模一樣的**！但我們的原始碼變得極其簡潔、可讀性高，而且非常容易修改（例如，要改成 32-bit，只需要把 `16` 改成 `32`）。

### 總結

你今天學到了 Verilog 中兩種最核心的建模方式：

1.  **行為級 (Behavioral)**: `assign y = s ? i1 : i0;`
    *   **優點**: 簡潔、易讀、意圖清晰。
    *   **描述**: 電路的功能是什麼。
    *   **何時使用**: 大部分時間都用這種。

2.  **結構級 (Structural)**: `generate for (...) begin mux_2_to_1 ... end`
    *   **優點**: 精確控制電路結構、模組化和複用。
    *   **描述**: 電路是由哪些子模組構成的。
    *   **何時使用**: 當你需要將設計好的小模組拼裝成一個大系統時。

理解這兩種建模方式的等價性，是成為一個優秀數位邏輯設計師的關鍵。你現在已經知道，一行簡單的行為級程式碼，背後可能代表著數十、數百個並行運作的硬體實例。

## Q: 如何用 MUX 做出 8 對 1 的多工器？

這個問題非常好！我們已經知道如何用基本邏輯閘做出 MUX，以及如何將 1-bit 的 MUX 擴展成 16-bit 的 MUX。現在，我們要來挑戰第三種擴展方式：**用小 MUX 堆疊出一個更多輸入的大 MUX**。

這完美地體現了**階層化設計 (Hierarchical Design)** 的思想，這在複雜的晶片設計中無處不在。

**我們的目標**：設計一個 8-to-1 MUX。
**我們的積木**：只有 2-to-1 MUX (和/或 4-to-1 MUX)。

---

### 第 1 步：分析問題

*   **輸入**：我們有 8 個資料輸入 (`i0` 到 `i7`)。
*   **輸出**：我們只有 1 個資料輸出 (`y`)。
*   **選擇信號**：要從 8 個選項中選出一個，我們需要 $log_2(8) = 3$ 條選擇線。我們稱之為 `s[2:0]`，也就是 `s[2]`, `s[1]`, `s[0]`。
    *   `s[0]` 是最低有效位 (LSB)。
    *   `s[2]` 是最高有效位 (MSB)。

### 方法一：用 2-to-1 MUX 搭成一棵「選擇樹」

我們可以把這個選擇過程想像成一個**淘汰賽**。8 位選手 (`i0` 到 `i7`) 參賽，經過三輪比賽，最終只有一個冠軍 (`y`)。每一場比賽，就是一個 2-to-1 MUX。

**賽程規劃 (也就是電路結構):**

1.  **第一輪 (Layer 1)**：
    *   `i0` 和 `i1` 比一場。
    *   `i2` 和 `i3` 比一場。
    *   `i4` 和 `i5` 比一場。
    *   `i6` 和 `i7` 比一場。
    *   這一輪總共需要 **4 個** 2-to-1 MUX。比賽的裁判是誰？是變化最快的選擇位 `s[0]`。

2.  **第二輪 (Layer 2)**：
    *   第一場的勝者和第二場的勝者比一場。
    *   第三場的勝者和第四場的勝者比一場。
    *   這一輪需要 **2 個** 2-to-1 MUX。裁判是 `s[1]`。

3.  **決賽 (Layer 3)**：
    *   第二輪的兩位勝者進行最後的決賽。
    *   這一輪需要 **1 個** 2-to-1 MUX。裁判是 `s[2]`。

總共需要 $4 + 2 + 1 = 7$ 個 2-to-1 MUX。

**電路圖：**


**Verilog 結構化實作：**

```verilog
// ==========================================================
// 我們的基本積木：1-bit 2-to-1 MUX
// ==========================================================
module mux_2_to_1 (
    input  wire i0,
    input  wire i1,
    input  wire s,
    output wire y
);
    assign y = s ? i1 : i0;
endmodule


// ==========================================================
// 模組: 一個由 7 個 2-to-1 MUX 組成的 8-to-1 MUX
// ==========================================================
module mux_8_to_1_structural (
    input wire i0, i1, i2, i3, i4, i5, i6, i7,
    input wire [2:0] s,
    output wire y
);

    // 宣告連接各層 MUX 的內部電線
    wire [3:0] layer1_outputs; // 存放第一層 4 個 MUX 的輸出
    wire [1:0] layer2_outputs; // 存放第二層 2 個 MUX 的輸出

    // ----- Layer 1: 由 s[0] 控制 -----
    mux_2_to_1 L1_M0 (.i0(i0), .i1(i1), .s(s[0]), .y(layer1_outputs[0]));
    mux_2_to_1 L1_M1 (.i0(i2), .i1(i3), .s(s[0]), .y(layer1_outputs[1]));
    mux_2_to_1 L1_M2 (.i0(i4), .i1(i5), .s(s[0]), .y(layer1_outputs[2]));
    mux_2_to_1 L1_M3 (.i0(i6), .i1(i7), .s(s[0]), .y(layer1_outputs[3]));

    // ----- Layer 2: 由 s[1] 控制 -----
    mux_2_to_1 L2_M0 (.i0(layer1_outputs[0]), .i1(layer1_outputs[1]), .s(s[1]), .y(layer2_outputs[0]));
    mux_2_to_1 L2_M1 (.i0(layer1_outputs[2]), .i1(layer1_outputs[3]), .s(s[1]), .y(layer2_outputs[1]));

    // ----- Layer 3 (Final): 由 s[2] 控制 -----
    mux_2_to_1 L3_M0 (.i0(layer2_outputs[0]), .i1(layer2_outputs[1]), .s(s[2]), .y(y));

endmodule
```

### 方法二：階層化設計 (Divide and Conquer)

這個方法更像是專業工程師的思維：我能不能用一些現成的、比 2-to-1 更大一點的積木來簡化我的設計？比如說，**4-to-1 MUX**。

**設計思路：**

1.  把 8 個輸入分成兩組：`{i0, i1, i2, i3}` 和 `{i4, i5, i6, i7}`。
2.  用**一個 4-to-1 MUX** 從第一組中選出一個。用哪幾條選擇線呢？當然是 `s[1:0]` (也就是 `s[1]` 和 `s[0]`)。
3.  用**另一個 4-to-1 MUX** 從第二組中選出一個。同樣使用 `s[1:0]` 作為選擇線。
4.  現在，我們得到了兩個候選輸出。最後，我們需要**一個 2-to-1 MUX** 來從這兩個候選者中選出最終的冠軍。用哪條線來選？就是我們還沒用過的最高位 `s[2]`！
    *   如果 `s[2]` 是 `0`，就選擇第一組的結果。
    *   如果 `s[2]` 是 `1`，就選擇第二組的結果。

這個設計總共需要 2 個 4-to-1 MUX 和 1 個 2-to-1 MUX。

**電路圖：**


**Verilog 階層化實作：**

```verilog
// ==========================================================
// 中間積木：一個行為級的 4-to-1 MUX
// ==========================================================
module mux_4_to_1 (
    input wire i0, i1, i2, i3,
    input wire [1:0] s,
    output reg y
);
    always @(*) begin
        case(s)
            2'b00: y = i0;
            2'b01: y = i1;
            2'b10: y = i2;
            2'b11: y = i3;
            default: y = 1'b0;
        endcase
    end
endmodule


// ==========================================================
// 模組: 由 2 個 4-to-1 MUX 和 1 個 2-to-1 MUX 組成的 8-to-1 MUX
// ==========================================================
module mux_8_to_1_hierarchical (
    input wire i0, i1, i2, i3, i4, i5, i6, i7,
    input wire [2:0] s,
    output wire y
);

    // 宣告內部電線，用來連接兩個 4-to-1 MUX 的輸出
    wire out_from_mux_low;  // 處理低位輸入 (i0-i3) 的 MUX 的輸出
    wire out_from_mux_high; // 處理高位輸入 (i4-i7) 的 MUX 的輸出

    // 實例化第一個 4-to-1 MUX，處理低位組
    mux_4_to_1 MUX_LOW (
        .i0(i0), .i1(i1), .i2(i2), .i3(i3),
        .s(s[1:0]), // 注意！它只關心 s 的低兩位
        .y(out_from_mux_low)
    );

    // 實例化第二個 4-to-1 MUX，處理高位組
    mux_4_to_1 MUX_HIGH (
        .i0(i4), .i1(i5), .i2(i6), .i3(i7),
        .s(s[1:0]), // 它也只關心 s 的低兩位
        .y(out_from_mux_high)
    );

    // 實例化最後的 2-to-1 MUX，根據 s 的最高位來做最終決定
    mux_2_to_1 FINAL_MUX (
        .i0(out_from_mux_low),
        .i1(out_from_mux_high),
        .s(s[2]), // 最終裁判是 s[2]
        .y(y)
    );

endmodule
```

### 總結

今天我們看到了兩種不同的結構化設計方法：

1.  **樹狀結構 (Tree Structure)**：完全用最基礎的 2-to-1 MUX 搭建，層層遞進。這種方法最能體現其底層的邏輯延遲（信號需要經過三層 MUX 才能到達輸出）。
2.  **階層化結構 (Hierarchical Structure)**：先用中等大小的模組 (`mux_4_to_1`) 處理局部問題，再將它們的結果組合起來。這種方法思路更清晰，也更容易複用現有設計。

這兩種方法最終實現的功能完全相同，但在設計思維上卻有所不同。掌握這種「化整為零」和「分而治之」的能力，是從資工學生邁向專業工程師的關鍵一步。


