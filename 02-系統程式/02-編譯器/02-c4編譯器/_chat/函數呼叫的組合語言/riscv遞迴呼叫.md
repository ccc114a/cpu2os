在 RISC-V 架構下，函數呼叫的過程通常會涉及以下幾個重要步驟：設定堆疊、傳遞參數、執行函數、以及返回結果。讓我們基於 Fibonacci 函數 `f(n)` 的遞迴呼叫過程來解釋在 RISC-V 處理器中的執行過程。

### 1. 函數呼叫基本步驟

在 RISC-V 中，函數呼叫遵循以下約定（呼叫規約）：
- **參數傳遞**：前 8 個參數使用暫存器 `a0` 到 `a7` 傳遞。如果有更多參數，會使用堆疊。
- **返回值**：返回值通常放在暫存器 `a0`（如果返回型別是整數）。
- **保存寄存器**：在進入函數之前，如果需要使用一些會被修改的寄存器，必須將其保存到堆疊，進入函數後再恢復。
- **堆疊操作**：當函數呼叫時，堆疊指針會調整，以便保存返回地址、舊的堆疊指針、臨時寄存器等。

### 2. Fibonacci 函數的遞迴過程

假設我們有一個 Fibonacci 函數 `f(n)`，當 `n` 小於等於 1 時返回 `n`，否則計算 `f(n-1) + f(n-2)`。

```c
int f(int n) {
    if (n <= 0) return 0;
    if (n == 1) return 1;
    return f(n-1) + f(n-2);
}
```

### 3. RISC-V 的程式碼執行過程

#### 函數呼叫流程

1. **初始化堆疊框架**：
   每次進入函數 `f`，我們首先要將當前的堆疊指針保存，並為局部變數保留空間。

   ```assembly
   f:
       addi sp, sp, -16        # 為堆疊分配空間，16 bytes
       sw   ra, 12(sp)         # 保存返回地址
       sw   s0, 8(sp)          # 保存上一個堆疊指針
       addi s0, sp, 16         # 更新堆疊指針
   ```

   這裡 `sp` 是堆疊指針，`ra` 是返回地址寄存器，`s0` 是保存上一層堆疊指針的暫存器。

2. **檢查遞迴基本情況**：
   在進入函數後，首先會檢查 `n <= 0` 或 `n == 1` 的情況。如果滿足條件，直接返回結果。

   ```assembly
       bge  a0, zero, check_n  # 檢查 n <= 0
       li   a0, 0              # 如果 n <= 0，返回 0
       j    done
   check_n:
       li   t0, 1
       beq  a0, t0, return_1   # 如果 n == 1，返回 1
       li   a0, 1              # 返回 1
       j    done
   ```

   這裡，`a0` 是用來傳遞 `n` 的參數，`t0` 是暫存器，`done` 是跳轉的標籤。

3. **進行遞迴呼叫**：
   如果 `n` 大於 1，我們需要進行兩次遞迴呼叫：`f(n-1)` 和 `f(n-2)`，並將結果相加。對於每次遞迴呼叫，我們需要減去 1 或 2 並再次呼叫 `f`。

   ```assembly
       addi a0, a0, -1         # 計算 n-1，存回 a0
       jal  f                   # 呼叫 f(n-1)
       mv   t1, a0             # 保存 f(n-1) 的結果

       addi a0, a0, -1         # 計算 n-2，存回 a0
       jal  f                   # 呼叫 f(n-2)
       add  a0, a0, t1         # f(n) = f(n-1) + f(n-2)
   ```

   這裡，`jal` 用來跳轉到 `f` 函數，並在完成後返回結果。`mv` 用來將結果保存到 `t1`，在後續的運算中使用。

4. **返回結果**：
   函數結束時，返回結果將保存在 `a0` 中，並且我們需要恢復堆疊指針並返回。

   ```assembly
   done:
       lw   ra, 12(sp)         # 恢復返回地址
       lw   s0, 8(sp)          # 恢復堆疊指針
       addi sp, sp, 16         # 恢復堆疊指針
       jr   ra                 # 返回到調用者
   ```

   `jr ra` 用來跳回返回地址，結束函數呼叫。

#### 5. `main` 函數呼叫 `f(7)` 的過程

`main` 函數中，會呼叫 `f(7)`，並打印結果。下面是這段程式碼的 RISC-V 指令：

```assembly
main:
       li   a0, 7              # 載入 7 作為參數
       jal  f                   # 呼叫 f(7)
       mv   a1, a0             # 將 f(7) 的結果存入 a1
       li   a0, 1              # 載入打印格式字符串的地址
       ecall                   # 執行系統呼叫（打印結果）
       li   a0, 0              # 設置返回值為 0
       ecall                   # 結束程序
```

- `jal f` 會跳轉到 `f` 函數，並開始遞迴計算。
- 在 `f(7)` 完成後，結果會存回 `a0`，並在 `main` 函數中打印出來。

### 6. 完整執行過程

1. `main` 呼叫 `f(7)`，並將參數 7 傳遞給 `f`。
2. `f(7)` 執行，並檢查是否小於等於 1。如果是，返回相應結果；否則，進行遞迴呼叫 `f(6)` 和 `f(5)`。
3. `f(6)` 和 `f(5)` 會繼續進行類似的遞迴，直到到達基礎情況（`n == 0` 或 `n == 1`）。
4. 遞迴結果會一層層返回，最終計算出 `f(7)` 的結果。
5. `main` 函數打印出結果並結束。

### 總結

在 RISC-V 架構下，函數呼叫過程涉及堆疊操作、寄存器保存與恢復、以及跳轉到函數實現。遞迴函數如 Fibonacci 函數的執行過程包括多次的 `jal` 跳轉指令來實現遞迴呼叫，並通過堆疊保存每次呼叫的返回地址和局部變數。在每次遞迴結束後，結果會依次返回並進行累加，最終計算出 Fibonacci 數列的結果。