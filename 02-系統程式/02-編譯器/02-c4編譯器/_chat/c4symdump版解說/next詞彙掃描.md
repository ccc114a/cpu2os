# c4.c 的詞彙分析器 (Lexer) 解析

這段程式碼實現了一個簡單但功能完整的詞彙分析器（lexer），用於將源碼文本轉換成標記（tokens）序列。讓我詳細解說這個函數的工作方式：

## 核心函數：`next()`

`next()` 函數負責從輸入源碼中識別並提取下一個標記（token）。它會掃描輸入字符串，辨識出語言中的關鍵字、標識符、數字、字符串、運算符等。

## 主要工作流程

1. 讀取當前字符並存入 `tk` 變量
2. 指針 `p` 前進到下一個字符
3. 根據當前字符的類型進行相應處理
4. 設置 `tk` 變量表示識別出的標記類型
5. 返回，讓編譯器進入下一階段處理

## 詳細解析

### 處理換行符

```c
if (tk == '\n') {
  if (src) {
    printf("%d: %.*s", line, p - lp, lp); // 印出該行
    lp = p; // lp = p = 新一行的原始碼開頭
    while (le < e) { // 印出上一行的所有目的碼
      printf("%8.4s", &"LLA ,IMM ,..."[*++le * 5]);
      if (*le <= ADJ) printf(" %d\n", *++le); else printf("\n");
    }
  }
  ++line;
}
```

這部分處理換行符，並且：
- 輸出當前行號和源碼
- 更新行指針 `lp` 到新行的開始
- 打印上一行生成的所有目標碼指令
- 行號自增

### 處理 `#include` 等預處理器指令

```c
else if (tk == '#') { // 取得 #include <stdio.h> 這類的一整行
  while (*p != 0 && *p != '\n') ++p;
}
```

這簡單地跳過任何以 `#` 開頭的行，如 `#include` 或 `#define`。

### 處理標識符和關鍵字

```c
else if ((tk >= 'a' && tk <= 'z') || (tk >= 'A' && tk <= 'Z') || tk == '_') {
  pp = p - 1;
  while ((*p >= 'a' && *p <= 'z') || (*p >= 'A' && *p <= 'Z') || (*p >= '0' && *p <= '9') || *p == '_')
    p++;
  id = sym;
  while (id[Tk]) { // 符號表還未結束
    if (p-pp == id[Len] && !memcmp((char *)id[Name], pp, p - pp)) { tk = id[Tk]; return; }
    id = id + Idsz;
  }
  id[Name] = (int)pp;
  id[Len] = p-pp;
  tk = id[Tk] = Id;
  return;
}
```

這部分處理變數名稱和關鍵字：
- 識別以字母或下劃線開頭的標識符
- 在符號表中查找該標識符是否已存在
- 如果存在，設置 `tk` 為該符號的類型並返回
- 如果不存在，則新增到符號表，並設置 `tk` 為 `Id`（標識符）

### 處理數字常量

```c
else if (tk >= '0' && tk <= '9') {
  if (ival = tk - '0') { 
    while (*p >= '0' && *p <= '9') ival = ival * 10 + *p++ - '0';
  }
  else if (*p == 'x' || *p == 'X') {
    while ((tk = *++p) && ((tk >= '0' && tk <= '9') || (tk >= 'a' && tk <= 'f') || (tk >= 'A' && tk <= 'F')))
      ival = ival * 16 + (tk & 15) + (tk >= 'A' ? 9 : 0);
  }
  else { 
    while (*p >= '0' && *p <= '7') ival = ival * 8 + *p++ - '0';
  }
  tk = Num;
  return;
}
```

這段程式碼處理數字常量，支持三種進制：
- 十進制（如 `123`）
- 十六進制（如 `0xABC`）
- 八進制（如 `0177`）

處理結果存儲在 `ival` 變量中，並設置 `tk` 為 `Num`。

### 處理註解和除法運算符

```c
else if (tk == '/') {
  if (*p == '/') {
    ++p;
    while (*p != 0 && *p != '\n') ++p;
  }
  else {
    tk = Div;
    return;
  }
}
```

這部分處理註解和除法運算符：
- 如果遇到 `//`，則跳過到行尾的所有字符
- 否則，將 `tk` 設置為 `Div`（除法）並返回

### 處理字符和字符串常量

```c
else if (tk == '\'' || tk == '"') {
  pp = data;
  while (*p != 0 && *p != tk) {
    if ((ival = *p++) == '\\') {
      if ((ival = *p++) == 'n') ival = '\n';
    }
    if (tk == '"') *data++ = ival;
  }
  ++p;
  if (tk == '"') ival = (int)pp; else tk = Num;
  return;
}
```

這段程式碼處理字符和字符串常量：
- 處理引號中的所有字符，包括轉義序列如 `\n`
- 對於字符串，將其存儲在 `data` 段中，並將 `ival` 設置為 `data` 的指針
- 對於字符，將其 ASCII 值存儲在 `ival` 中，並設置 `tk` 為 `Num`

### 處理各種運算符

```c
else if (tk == '=') { if (*p == '=') { ++p; tk = Eq; } else tk = Assign; return; }
else if (tk == '+') { if (*p == '+') { ++p; tk = Inc; } else tk = Add; return; }
...
```

這部分處理各種運算符，包括：
- 單字符運算符（如 `+`, `-`, `*`, `/`）
- 雙字符運算符（如 `==`, `!=`, `<=`, `>=`, `++`, `--`）
- 其他特殊符號（如 `{`, `}`, `(`, `)`, `;`, `,`）

對於每種情況，它都會設置適當的 `tk` 值並返回。

## 核心數據結構

雖然這段程式碼中沒有直接定義，但可以推斷出以下核心數據結構：

1. `tk`：當前標記的類型
2. `p`：指向源碼的指針
3. `lp`：指向當前行開始的指針
4. `ival`：數字、字符或字符串常量的值
5. `id`：當前標識符在符號表中的位置
6. `sym`：符號表的起始位置
7. `data`：數據段的起始位置
8. `line`：當前行號

## 總結

這個詞彙分析器是一個簡單但功能完整的實現，它能夠：

1. 識別語言中的所有標記類型
2. 處理各種字面常量（數字、字符、字符串）
3. 管理符號表
4. 處理註解和預處理器指令
5. 在調試模式下輸出有用的信息

這個 lexer 是整個編譯器的第一階段，它將源碼文本轉換為標記序列，為後續的語法分析和代碼生成階段提供輸入。